"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ownership = exports.SchemaStatus = exports.GraphQLSchemaException = exports.OutputType = exports.TypeDefinitionFormat = exports.ResolverKind = exports.GraphQLApiVisibility = exports.DefaultAction = exports.FieldLogLevel = exports.GraphQLApiType = exports.ConflictHandlerType = exports.ConflictDetectionType = exports.DataSourceType = exports.RelationalDatabaseSourceType = exports.AuthorizationType = exports.UnauthorizedException = exports.LimitExceededException = exports.ConcurrentModificationException = exports.SourceApiAssociationStatus = exports.MergeType = exports.NotFoundException = exports.InternalFailureException = exports.BadRequestException = exports.BadRequestReason = exports.RuntimeName = exports.ApiLimitExceededException = exports.ApiKeyValidityOutOfBoundsException = exports.ApiKeyLimitExceededException = exports.ApiCacheType = exports.ApiCacheStatus = exports.ApiCachingBehavior = exports.AssociationStatus = exports.AuthenticationType = exports.AccessDeniedException = void 0;
const AppSyncServiceException_1 = require("./AppSyncServiceException");
class AccessDeniedException extends AppSyncServiceException_1.AppSyncServiceException {
    constructor(opts) {
        super({
            name: "AccessDeniedException",
            $fault: "client",
            ...opts,
        });
        this.name = "AccessDeniedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, AccessDeniedException.prototype);
    }
}
exports.AccessDeniedException = AccessDeniedException;
exports.AuthenticationType = {
    AMAZON_COGNITO_USER_POOLS: "AMAZON_COGNITO_USER_POOLS",
    API_KEY: "API_KEY",
    AWS_IAM: "AWS_IAM",
    AWS_LAMBDA: "AWS_LAMBDA",
    OPENID_CONNECT: "OPENID_CONNECT",
};
exports.AssociationStatus = {
    Failed: "FAILED",
    Processing: "PROCESSING",
    Success: "SUCCESS",
};
exports.ApiCachingBehavior = {
    FULL_REQUEST_CACHING: "FULL_REQUEST_CACHING",
    PER_RESOLVER_CACHING: "PER_RESOLVER_CACHING",
};
exports.ApiCacheStatus = {
    AVAILABLE: "AVAILABLE",
    CREATING: "CREATING",
    DELETING: "DELETING",
    FAILED: "FAILED",
    MODIFYING: "MODIFYING",
};
exports.ApiCacheType = {
    LARGE: "LARGE",
    LARGE_12X: "LARGE_12X",
    LARGE_2X: "LARGE_2X",
    LARGE_4X: "LARGE_4X",
    LARGE_8X: "LARGE_8X",
    MEDIUM: "MEDIUM",
    R4_2XLARGE: "R4_2XLARGE",
    R4_4XLARGE: "R4_4XLARGE",
    R4_8XLARGE: "R4_8XLARGE",
    R4_LARGE: "R4_LARGE",
    R4_XLARGE: "R4_XLARGE",
    SMALL: "SMALL",
    T2_MEDIUM: "T2_MEDIUM",
    T2_SMALL: "T2_SMALL",
    XLARGE: "XLARGE",
};
class ApiKeyLimitExceededException extends AppSyncServiceException_1.AppSyncServiceException {
    constructor(opts) {
        super({
            name: "ApiKeyLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "ApiKeyLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ApiKeyLimitExceededException.prototype);
    }
}
exports.ApiKeyLimitExceededException = ApiKeyLimitExceededException;
class ApiKeyValidityOutOfBoundsException extends AppSyncServiceException_1.AppSyncServiceException {
    constructor(opts) {
        super({
            name: "ApiKeyValidityOutOfBoundsException",
            $fault: "client",
            ...opts,
        });
        this.name = "ApiKeyValidityOutOfBoundsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ApiKeyValidityOutOfBoundsException.prototype);
    }
}
exports.ApiKeyValidityOutOfBoundsException = ApiKeyValidityOutOfBoundsException;
class ApiLimitExceededException extends AppSyncServiceException_1.AppSyncServiceException {
    constructor(opts) {
        super({
            name: "ApiLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "ApiLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ApiLimitExceededException.prototype);
    }
}
exports.ApiLimitExceededException = ApiLimitExceededException;
exports.RuntimeName = {
    APPSYNC_JS: "APPSYNC_JS",
};
exports.BadRequestReason = {
    CODE_ERROR: "CODE_ERROR",
};
class BadRequestException extends AppSyncServiceException_1.AppSyncServiceException {
    constructor(opts) {
        super({
            name: "BadRequestException",
            $fault: "client",
            ...opts,
        });
        this.name = "BadRequestException";
        this.$fault = "client";
        Object.setPrototypeOf(this, BadRequestException.prototype);
        this.reason = opts.reason;
        this.detail = opts.detail;
    }
}
exports.BadRequestException = BadRequestException;
class InternalFailureException extends AppSyncServiceException_1.AppSyncServiceException {
    constructor(opts) {
        super({
            name: "InternalFailureException",
            $fault: "server",
            ...opts,
        });
        this.name = "InternalFailureException";
        this.$fault = "server";
        Object.setPrototypeOf(this, InternalFailureException.prototype);
    }
}
exports.InternalFailureException = InternalFailureException;
class NotFoundException extends AppSyncServiceException_1.AppSyncServiceException {
    constructor(opts) {
        super({
            name: "NotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "NotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, NotFoundException.prototype);
    }
}
exports.NotFoundException = NotFoundException;
exports.MergeType = {
    AUTO_MERGE: "AUTO_MERGE",
    MANUAL_MERGE: "MANUAL_MERGE",
};
exports.SourceApiAssociationStatus = {
    AUTO_MERGE_SCHEDULE_FAILED: "AUTO_MERGE_SCHEDULE_FAILED",
    DELETION_FAILED: "DELETION_FAILED",
    DELETION_IN_PROGRESS: "DELETION_IN_PROGRESS",
    DELETION_SCHEDULED: "DELETION_SCHEDULED",
    MERGE_FAILED: "MERGE_FAILED",
    MERGE_IN_PROGRESS: "MERGE_IN_PROGRESS",
    MERGE_SCHEDULED: "MERGE_SCHEDULED",
    MERGE_SUCCESS: "MERGE_SUCCESS",
};
class ConcurrentModificationException extends AppSyncServiceException_1.AppSyncServiceException {
    constructor(opts) {
        super({
            name: "ConcurrentModificationException",
            $fault: "client",
            ...opts,
        });
        this.name = "ConcurrentModificationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ConcurrentModificationException.prototype);
    }
}
exports.ConcurrentModificationException = ConcurrentModificationException;
class LimitExceededException extends AppSyncServiceException_1.AppSyncServiceException {
    constructor(opts) {
        super({
            name: "LimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "LimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, LimitExceededException.prototype);
    }
}
exports.LimitExceededException = LimitExceededException;
class UnauthorizedException extends AppSyncServiceException_1.AppSyncServiceException {
    constructor(opts) {
        super({
            name: "UnauthorizedException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnauthorizedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnauthorizedException.prototype);
    }
}
exports.UnauthorizedException = UnauthorizedException;
exports.AuthorizationType = {
    AWS_IAM: "AWS_IAM",
};
exports.RelationalDatabaseSourceType = {
    RDS_HTTP_ENDPOINT: "RDS_HTTP_ENDPOINT",
};
exports.DataSourceType = {
    AMAZON_DYNAMODB: "AMAZON_DYNAMODB",
    AMAZON_ELASTICSEARCH: "AMAZON_ELASTICSEARCH",
    AMAZON_EVENTBRIDGE: "AMAZON_EVENTBRIDGE",
    AMAZON_OPENSEARCH_SERVICE: "AMAZON_OPENSEARCH_SERVICE",
    AWS_LAMBDA: "AWS_LAMBDA",
    HTTP: "HTTP",
    NONE: "NONE",
    RELATIONAL_DATABASE: "RELATIONAL_DATABASE",
};
exports.ConflictDetectionType = {
    NONE: "NONE",
    VERSION: "VERSION",
};
exports.ConflictHandlerType = {
    AUTOMERGE: "AUTOMERGE",
    LAMBDA: "LAMBDA",
    NONE: "NONE",
    OPTIMISTIC_CONCURRENCY: "OPTIMISTIC_CONCURRENCY",
};
exports.GraphQLApiType = {
    GRAPHQL: "GRAPHQL",
    MERGED: "MERGED",
};
exports.FieldLogLevel = {
    ALL: "ALL",
    ERROR: "ERROR",
    NONE: "NONE",
};
exports.DefaultAction = {
    ALLOW: "ALLOW",
    DENY: "DENY",
};
exports.GraphQLApiVisibility = {
    GLOBAL: "GLOBAL",
    PRIVATE: "PRIVATE",
};
exports.ResolverKind = {
    PIPELINE: "PIPELINE",
    UNIT: "UNIT",
};
exports.TypeDefinitionFormat = {
    JSON: "JSON",
    SDL: "SDL",
};
exports.OutputType = {
    JSON: "JSON",
    SDL: "SDL",
};
class GraphQLSchemaException extends AppSyncServiceException_1.AppSyncServiceException {
    constructor(opts) {
        super({
            name: "GraphQLSchemaException",
            $fault: "client",
            ...opts,
        });
        this.name = "GraphQLSchemaException";
        this.$fault = "client";
        Object.setPrototypeOf(this, GraphQLSchemaException.prototype);
    }
}
exports.GraphQLSchemaException = GraphQLSchemaException;
exports.SchemaStatus = {
    Active: "ACTIVE",
    Deleting: "DELETING",
    Failed: "FAILED",
    NotApplicable: "NOT_APPLICABLE",
    Processing: "PROCESSING",
    Success: "SUCCESS",
};
exports.Ownership = {
    CURRENT_ACCOUNT: "CURRENT_ACCOUNT",
    OTHER_ACCOUNTS: "OTHER_ACCOUNTS",
};
