import debounce from 'debounce-promise';
import parcelWatcher from '@parcel/watcher';
import parseGitIgnore from 'parse-gitignore';
import path from 'path';
import fs from 'fs';
import _open from 'open';
import EventEmitter from 'events';
import { DescribeStacksCommand, } from '@aws-sdk/client-cloudformation';
import { AmplifyPrompter } from '@aws-amplify/cli-core';
import { createFilesChangesTracker, } from './files_changes_tracker.js';
export const CDK_BOOTSTRAP_STACK_NAME = 'CDKToolkit';
export const CDK_BOOTSTRAP_VERSION_KEY = 'BootstrapVersion';
export const CDK_MIN_BOOTSTRAP_VERSION = 6;
// TODO: finalize bootstrap url: https://github.com/aws-amplify/amplify-backend/issues/338
/**
 * Constructs Amplify Console bootstrap URL for a given region
 * @param region AWS region
 * @returns Amplify Console bootstrap URL
 */
export const getBootstrapUrl = (region) => `https://${region}.console.aws.amazon.com/amplify/create/bootstrap?region=${region}`;
/**
 * Runs a file watcher and deploys
 */
export class FileWatchingSandbox extends EventEmitter {
    backendIdSandboxResolver;
    executor;
    cfnClient;
    open;
    watcherSubscription;
    outputFilesExcludedFromWatch = ['.amplify'];
    filesChangesTracker;
    /**
     * Creates a watcher process for this instance
     */
    constructor(backendIdSandboxResolver, executor, cfnClient, open = _open) {
        process.once('SIGINT', () => void this.stop());
        process.once('SIGTERM', () => void this.stop());
        super();
        this.backendIdSandboxResolver = backendIdSandboxResolver;
        this.executor = executor;
        this.cfnClient = cfnClient;
        this.open = open;
    }
    /**
     * @inheritdoc
     */
    emit(eventName, ...args) {
        return super.emit(eventName, ...args);
    }
    /**
     * @inheritdoc
     */
    on(eventName, listener) {
        return super.on(eventName, listener);
    }
    /**
     * @inheritdoc
     */
    start = async (options) => {
        this.filesChangesTracker = await createFilesChangesTracker(options.dir ?? './amplify');
        const bootstrapped = await this.isBootstrapped();
        if (!bootstrapped) {
            console.log('The given region has not been bootstrapped. Sign in to console as a Root user or Admin to complete the bootstrap process and re-run the amplify sandbox command.');
            // get region from an available sdk client;
            const region = await this.cfnClient.config.region();
            await this.open(getBootstrapUrl(region));
            return;
        }
        const ignoredPaths = this.getGitIgnoredPaths();
        this.outputFilesExcludedFromWatch =
            this.outputFilesExcludedFromWatch.concat(...ignoredPaths);
        console.debug(`[Sandbox] Initializing...`);
        // Since 'cdk deploy' is a relatively slow operation for a 'watch' process,
        // introduce a concurrency latch that tracks the state.
        // This way, if file change events arrive when a 'cdk deploy' is still executing,
        // we will batch them, and trigger another 'cdk deploy' after the current one finishes,
        // making sure 'cdk deploy's  always execute one at a time.
        // Here's a diagram showing the state transitions:
        // --------    file changed     --------------    file changed     --------------  file changed
        // |      | ------------------> |            | ------------------> |            | --------------|
        // | open |                     | deploying  |                     |   queued   |               |
        // |      | <------------------ |            | <------------------ |            | <-------------|
        // --------  'cdk deploy' done  --------------  'cdk deploy' done  --------------
        let latch = 'open';
        const deployAndWatch = debounce(async () => {
            latch = 'deploying';
            await this.deploy(options);
            // If latch is still 'deploying' after the 'await', that's fine,
            // but if it's 'queued', that means we need to deploy again
            while (latch === 'queued') {
                // TypeScript doesn't realize latch can change between 'awaits' ¯\_(ツ)_/¯,
                // and thinks the above 'while' condition is always 'false' without the cast
                latch = 'deploying';
                console.log("[Sandbox] Detected file changes while previous deployment was in progress. Invoking 'sandbox' again");
                await this.deploy(options);
            }
            latch = 'open';
            this.emitWatching();
        });
        this.watcherSubscription = await parcelWatcher.subscribe(options.dir ?? './amplify', async (_, events) => {
            // Log and track file changes.
            await Promise.all(events.map(({ type: eventName, path }) => {
                this.filesChangesTracker.trackFileChange(path);
                console.log(`[Sandbox] Triggered due to a file ${eventName} event: ${path}`);
            }));
            if (latch === 'open') {
                await deployAndWatch();
            }
            else {
                // this means latch is either 'deploying' or 'queued'
                latch = 'queued';
                console.log('[Sandbox] Previous deployment is still in progress. ' +
                    'Will queue for another deployment after this one finishes');
            }
        }, {
            ignore: this.outputFilesExcludedFromWatch.concat(...(options.exclude ?? [])),
        });
        // Start the first full deployment without waiting for a file change
        await deployAndWatch();
    };
    /**
     * @inheritdoc
     */
    stop = async () => {
        console.debug(`[Sandbox] Shutting down`);
        // can be undefined if command exits before subscription
        await this.watcherSubscription?.unsubscribe();
    };
    /**
     * @inheritdoc
     */
    delete = async (options) => {
        console.log('[Sandbox] Deleting all the resources in the sandbox environment...');
        await this.executor.destroy(await this.backendIdSandboxResolver(options.name));
        this.emit('successfulDeletion');
        console.log('[Sandbox] Finished deleting.');
    };
    shouldValidateAppSources = () => {
        const snapshot = this.filesChangesTracker.getAndResetSnapshot();
        // if zero files changed this indicates initial deployment
        const shouldValidateOnColdStart = snapshot.hadTypeScriptFilesAtStart &&
            !snapshot.didAnyFileChangeSinceStart;
        return (shouldValidateOnColdStart ||
            snapshot.didAnyTypeScriptFileChangeSinceLastSnapshot);
    };
    deploy = async (options) => {
        try {
            const deployResult = await this.executor.deploy(await this.backendIdSandboxResolver(options.name), 
            // It's important to pass this as callback so that debounce does
            // not reset tracker prematurely
            this.shouldValidateAppSources);
            console.debug('[Sandbox] Running successfulDeployment event handlers');
            this.emit('successfulDeployment', deployResult);
        }
        catch (error) {
            // Print the meaningful message
            console.log(this.getErrorMessage(error));
            this.emit('failedDeployment', error);
            // If the error is because of a non-allowed destructive change such as
            // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cognito-userpool.html#cfn-cognito-userpool-aliasattributes
            // offer to recreate the sandbox or revert the change
            if (error instanceof Error &&
                error.message.includes('UpdateNotSupported')) {
                await this.handleUnsupportedDestructiveChanges(options);
            }
            // else do not propagate and let the sandbox continue to run
        }
    };
    reset = async (options) => {
        await this.delete({ name: options.name });
        await this.start(options);
    };
    /**
     * Just a shorthand console log to indicate whenever watcher is going idle
     */
    emitWatching = () => {
        console.log(`[Sandbox] Watching for file changes...`);
    };
    /**
     * Reads and parses .gitignore file and returns the list of paths
     */
    getGitIgnoredPaths = () => {
        const gitIgnoreFilePath = path.join(process.cwd(), '.gitignore');
        if (fs.existsSync(gitIgnoreFilePath)) {
            return parseGitIgnore
                .parse(gitIgnoreFilePath)
                .patterns.map((pattern) => pattern.startsWith('/') ? pattern.substring(1) : pattern)
                .filter((pattern) => {
                if (pattern.startsWith('!')) {
                    console.log(`[Sandbox] Pattern ${pattern} found in .gitignore. "${pattern.substring(1)}" will not be watched if other patterns in .gitignore are excluding it.`);
                    return false;
                }
                return true;
            });
        }
        return [];
    };
    /**
     * Checks if a given region has been bootstrapped with >= min version using CFN describeStacks with CDKToolKit.
     * @returns A Boolean that represents if region has been bootstrapped.
     */
    isBootstrapped = async () => {
        try {
            const { Stacks: stacks } = await this.cfnClient.send(new DescribeStacksCommand({
                StackName: CDK_BOOTSTRAP_STACK_NAME,
            }));
            const bootstrapVersion = stacks?.[0]?.Outputs?.find((output) => output.OutputKey === CDK_BOOTSTRAP_VERSION_KEY)?.OutputValue;
            if (!bootstrapVersion ||
                Number(bootstrapVersion) < CDK_MIN_BOOTSTRAP_VERSION) {
                return false;
            }
            return true;
        }
        catch (e) {
            if (e &&
                typeof e === 'object' &&
                'message' in e &&
                typeof e.message === 'string' &&
                e.message.includes('does not exist')) {
                return false;
            }
            // If we are unable to get the stack info due to other reasons(AccessDenied), we fail fast.
            throw e;
        }
    };
    /**
     * Generates a printable error message from the thrown error
     */
    getErrorMessage = (error) => {
        let message;
        if (error instanceof Error) {
            message = error.message;
            // Add the downstream exception
            if (error.cause && error.cause instanceof Error) {
                message = `${message}\nCaused By: ${error.cause instanceof Error
                    ? error.cause.message
                    : String(error.cause)}`;
            }
        }
        else
            message = String(error);
        return message;
    };
    handleUnsupportedDestructiveChanges = async (options) => {
        console.error('[Sandbox] We cannot deploy your new changes. You can either revert them or recreate your sandbox with the new changes (deleting all user data)');
        // offer to recreate the sandbox with new properties
        const answer = await AmplifyPrompter.yesOrNo({
            message: 'Would you like to recreate your sandbox (deleting all user data)?',
            defaultValue: false,
        });
        if (answer) {
            await this.stop();
            await this.reset(options);
        }
        // else let the sandbox continue so customers can revert their changes
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZV93YXRjaGluZ19zYW5kYm94LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2ZpbGVfd2F0Y2hpbmdfc2FuZGJveC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLFFBQVEsTUFBTSxrQkFBa0IsQ0FBQztBQUN4QyxPQUFPLGFBQTRCLE1BQU0saUJBQWlCLENBQUM7QUFTM0QsT0FBTyxjQUFjLE1BQU0saUJBQWlCLENBQUM7QUFDN0MsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBQ3hCLE9BQU8sRUFBRSxNQUFNLElBQUksQ0FBQztBQUNwQixPQUFPLEtBQUssTUFBTSxNQUFNLENBQUM7QUFDekIsT0FBTyxZQUFZLE1BQU0sUUFBUSxDQUFDO0FBQ2xDLE9BQU8sRUFFTCxxQkFBcUIsR0FDdEIsTUFBTSxnQ0FBZ0MsQ0FBQztBQUN4QyxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDeEQsT0FBTyxFQUVMLHlCQUF5QixHQUMxQixNQUFNLDRCQUE0QixDQUFDO0FBRXBDLE1BQU0sQ0FBQyxNQUFNLHdCQUF3QixHQUFHLFlBQVksQ0FBQztBQUNyRCxNQUFNLENBQUMsTUFBTSx5QkFBeUIsR0FBRyxrQkFBa0IsQ0FBQztBQUM1RCxNQUFNLENBQUMsTUFBTSx5QkFBeUIsR0FBRyxDQUFDLENBQUM7QUFFM0MsMEZBQTBGO0FBQzFGOzs7O0dBSUc7QUFDSCxNQUFNLENBQUMsTUFBTSxlQUFlLEdBQUcsQ0FBQyxNQUFjLEVBQUUsRUFBRSxDQUNoRCxXQUFXLE1BQU0sMkRBQTJELE1BQU0sRUFBRSxDQUFDO0FBRXZGOztHQUVHO0FBQ0gsTUFBTSxPQUFPLG1CQUFvQixTQUFRLFlBQVk7SUFTaEM7SUFDQTtJQUNBO0lBQ0E7SUFYWCxtQkFBbUIsQ0FBd0M7SUFDM0QsNEJBQTRCLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUM1QyxtQkFBbUIsQ0FBc0I7SUFFakQ7O09BRUc7SUFDSCxZQUNtQix3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c291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlYm91bmNlIGZyb20gJ2RlYm91bmNlLXByb21pc2UnO1xuaW1wb3J0IHBhcmNlbFdhdGNoZXIsIHsgc3Vic2NyaWJlIH0gZnJvbSAnQHBhcmNlbC93YXRjaGVyJztcbmltcG9ydCB7IEFtcGxpZnlTYW5kYm94RXhlY3V0b3IgfSBmcm9tICcuL3NhbmRib3hfZXhlY3V0b3IuanMnO1xuaW1wb3J0IHtcbiAgQmFja2VuZElkU2FuZGJveFJlc29sdmVyLFxuICBTYW5kYm94LFxuICBTYW5kYm94RGVsZXRlT3B0aW9ucyxcbiAgU2FuZGJveEV2ZW50cyxcbiAgU2FuZGJveE9wdGlvbnMsXG59IGZyb20gJy4vc2FuZGJveC5qcyc7XG5pbXBvcnQgcGFyc2VHaXRJZ25vcmUgZnJvbSAncGFyc2UtZ2l0aWdub3JlJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBfb3BlbiBmcm9tICdvcGVuJztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7XG4gIENsb3VkRm9ybWF0aW9uQ2xpZW50LFxuICBEZXNjcmliZVN0YWNrc0NvbW1hbmQsXG59IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgeyBBbXBsaWZ5UHJvbXB0ZXIgfSBmcm9tICdAYXdzLWFtcGxpZnkvY2xpLWNvcmUnO1xuaW1wb3J0IHtcbiAgRmlsZXNDaGFuZ2VzVHJhY2tlcixcbiAgY3JlYXRlRmlsZXNDaGFuZ2VzVHJhY2tlcixcbn0gZnJvbSAnLi9maWxlc19jaGFuZ2VzX3RyYWNrZXIuanMnO1xuXG5leHBvcnQgY29uc3QgQ0RLX0JPT1RTVFJBUF9TVEFDS19OQU1FID0gJ0NES1Rvb2xraXQnO1xuZXhwb3J0IGNvbnN0IENES19CT09UU1RSQVBfVkVSU0lPTl9LRVkgPSAnQm9vdHN0cmFwVmVyc2lvbic7XG5leHBvcnQgY29uc3QgQ0RLX01JTl9CT09UU1RSQVBfVkVSU0lPTiA9IDY7XG5cbi8vIFRPRE86IGZpbmFsaXplIGJvb3RzdHJhcCB1cmw6IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MtYW1wbGlmeS9hbXBsaWZ5LWJhY2tlbmQvaXNzdWVzLzMzOFxuLyoqXG4gKiBDb25zdHJ1Y3RzIEFtcGxpZnkgQ29uc29sZSBib290c3RyYXAgVVJMIGZvciBhIGdpdmVuIHJlZ2lvblxuICogQHBhcmFtIHJlZ2lvbiBBV1MgcmVnaW9uXG4gKiBAcmV0dXJucyBBbXBsaWZ5IENvbnNvbGUgYm9vdHN0cmFwIFVSTFxuICovXG5leHBvcnQgY29uc3QgZ2V0Qm9vdHN0cmFwVXJsID0gKHJlZ2lvbjogc3RyaW5nKSA9PlxuICBgaHR0cHM6Ly8ke3JlZ2lvbn0uY29uc29sZS5hd3MuYW1hem9uLmNvbS9hbXBsaWZ5L2NyZWF0ZS9ib290c3RyYXA/cmVnaW9uPSR7cmVnaW9ufWA7XG5cbi8qKlxuICogUnVucyBhIGZpbGUgd2F0Y2hlciBhbmQgZGVwbG95c1xuICovXG5leHBvcnQgY2xhc3MgRmlsZVdhdGNoaW5nU2FuZGJveCBleHRlbmRzIEV2ZW50RW1pdHRlciBpbXBsZW1lbnRzIFNhbmRib3gge1xuICBwcml2YXRlIHdhdGNoZXJTdWJzY3JpcHRpb246IEF3YWl0ZWQ8UmV0dXJuVHlwZTx0eXBlb2Ygc3Vic2NyaWJlPj47XG4gIHByaXZhdGUgb3V0cHV0RmlsZXNFeGNsdWRlZEZyb21XYXRjaCA9IFsnLmFtcGxpZnknXTtcbiAgcHJpdmF0ZSBmaWxlc0NoYW5nZXNUcmFja2VyOiBGaWxlc0NoYW5nZXNUcmFja2VyO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgd2F0Y2hlciBwcm9jZXNzIGZvciB0aGlzIGluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGJhY2tlbmRJZFNhbmRib3hSZXNvbHZlcjogQmFja2VuZElkU2FuZGJveFJlc29sdmVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZXhlY3V0b3I6IEFtcGxpZnlTYW5kYm94RXhlY3V0b3IsXG4gICAgcHJpdmF0ZSByZWFkb25seSBjZm5DbGllbnQ6IENsb3VkRm9ybWF0aW9uQ2xpZW50LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgb3BlbiA9IF9vcGVuXG4gICkge1xuICAgIHByb2Nlc3Mub25jZSgnU0lHSU5UJywgKCkgPT4gdm9pZCB0aGlzLnN0b3AoKSk7XG4gICAgcHJvY2Vzcy5vbmNlKCdTSUdURVJNJywgKCkgPT4gdm9pZCB0aGlzLnN0b3AoKSk7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgb3ZlcnJpZGUgZW1pdChldmVudE5hbWU6IFNhbmRib3hFdmVudHMsIC4uLmFyZ3M6IHVua25vd25bXSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50TmFtZSwgLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIG92ZXJyaWRlIG9uKFxuICAgIGV2ZW50TmFtZTogU2FuZGJveEV2ZW50cyxcbiAgICBsaXN0ZW5lcjogKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZFxuICApOiB0aGlzIHtcbiAgICByZXR1cm4gc3VwZXIub24oZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIHN0YXJ0ID0gYXN5bmMgKG9wdGlvbnM6IFNhbmRib3hPcHRpb25zKSA9PiB7XG4gICAgdGhpcy5maWxlc0NoYW5nZXNUcmFja2VyID0gYXdhaXQgY3JlYXRlRmlsZXNDaGFuZ2VzVHJhY2tlcihcbiAgICAgIG9wdGlvbnMuZGlyID8/ICcuL2FtcGxpZnknXG4gICAgKTtcbiAgICBjb25zdCBib290c3RyYXBwZWQgPSBhd2FpdCB0aGlzLmlzQm9vdHN0cmFwcGVkKCk7XG4gICAgaWYgKCFib290c3RyYXBwZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAnVGhlIGdpdmVuIHJlZ2lvbiBoYXMgbm90IGJlZW4gYm9vdHN0cmFwcGVkLiBTaWduIGluIHRvIGNvbnNvbGUgYXMgYSBSb290IHVzZXIgb3IgQWRtaW4gdG8gY29tcGxldGUgdGhlIGJvb3RzdHJhcCBwcm9jZXNzIGFuZCByZS1ydW4gdGhlIGFtcGxpZnkgc2FuZGJveCBjb21tYW5kLidcbiAgICAgICk7XG4gICAgICAvLyBnZXQgcmVnaW9uIGZyb20gYW4gYXZhaWxhYmxlIHNkayBjbGllbnQ7XG4gICAgICBjb25zdCByZWdpb24gPSBhd2FpdCB0aGlzLmNmbkNsaWVudC5jb25maWcucmVnaW9uKCk7XG4gICAgICBhd2FpdCB0aGlzLm9wZW4oZ2V0Qm9vdHN0cmFwVXJsKHJlZ2lvbikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGlnbm9yZWRQYXRocyA9IHRoaXMuZ2V0R2l0SWdub3JlZFBhdGhzKCk7XG4gICAgdGhpcy5vdXRwdXRGaWxlc0V4Y2x1ZGVkRnJvbVdhdGNoID1cbiAgICAgIHRoaXMub3V0cHV0RmlsZXNFeGNsdWRlZEZyb21XYXRjaC5jb25jYXQoLi4uaWdub3JlZFBhdGhzKTtcblxuICAgIGNvbnNvbGUuZGVidWcoYFtTYW5kYm94XSBJbml0aWFsaXppbmcuLi5gKTtcbiAgICAvLyBTaW5jZSAnY2RrIGRlcGxveScgaXMgYSByZWxhdGl2ZWx5IHNsb3cgb3BlcmF0aW9uIGZvciBhICd3YXRjaCcgcHJvY2VzcyxcbiAgICAvLyBpbnRyb2R1Y2UgYSBjb25jdXJyZW5jeSBsYXRjaCB0aGF0IHRyYWNrcyB0aGUgc3RhdGUuXG4gICAgLy8gVGhpcyB3YXksIGlmIGZpbGUgY2hhbmdlIGV2ZW50cyBhcnJpdmUgd2hlbiBhICdjZGsgZGVwbG95JyBpcyBzdGlsbCBleGVjdXRpbmcsXG4gICAgLy8gd2Ugd2lsbCBiYXRjaCB0aGVtLCBhbmQgdHJpZ2dlciBhbm90aGVyICdjZGsgZGVwbG95JyBhZnRlciB0aGUgY3VycmVudCBvbmUgZmluaXNoZXMsXG4gICAgLy8gbWFraW5nIHN1cmUgJ2NkayBkZXBsb3kncyAgYWx3YXlzIGV4ZWN1dGUgb25lIGF0IGEgdGltZS5cbiAgICAvLyBIZXJlJ3MgYSBkaWFncmFtIHNob3dpbmcgdGhlIHN0YXRlIHRyYW5zaXRpb25zOlxuXG4gICAgLy8gLS0tLS0tLS0gICAgZmlsZSBjaGFuZ2VkICAgICAtLS0tLS0tLS0tLS0tLSAgICBmaWxlIGNoYW5nZWQgICAgIC0tLS0tLS0tLS0tLS0tICBmaWxlIGNoYW5nZWRcbiAgICAvLyB8ICAgICAgfCAtLS0tLS0tLS0tLS0tLS0tLS0+IHwgICAgICAgICAgICB8IC0tLS0tLS0tLS0tLS0tLS0tLT4gfCAgICAgICAgICAgIHwgLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gfCBvcGVuIHwgICAgICAgICAgICAgICAgICAgICB8IGRlcGxveWluZyAgfCAgICAgICAgICAgICAgICAgICAgIHwgICBxdWV1ZWQgICB8ICAgICAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICB8IDwtLS0tLS0tLS0tLS0tLS0tLS0gfCAgICAgICAgICAgIHwgPC0tLS0tLS0tLS0tLS0tLS0tLSB8ICAgICAgICAgICAgfCA8LS0tLS0tLS0tLS0tLXxcbiAgICAvLyAtLS0tLS0tLSAgJ2NkayBkZXBsb3knIGRvbmUgIC0tLS0tLS0tLS0tLS0tICAnY2RrIGRlcGxveScgZG9uZSAgLS0tLS0tLS0tLS0tLS1cblxuICAgIGxldCBsYXRjaDogJ29wZW4nIHwgJ2RlcGxveWluZycgfCAncXVldWVkJyA9ICdvcGVuJztcblxuICAgIGNvbnN0IGRlcGxveUFuZFdhdGNoID0gZGVib3VuY2UoYXN5bmMgKCkgPT4ge1xuICAgICAgbGF0Y2ggPSAnZGVwbG95aW5nJztcbiAgICAgIGF3YWl0IHRoaXMuZGVwbG95KG9wdGlvbnMpO1xuXG4gICAgICAvLyBJZiBsYXRjaCBpcyBzdGlsbCAnZGVwbG95aW5nJyBhZnRlciB0aGUgJ2F3YWl0JywgdGhhdCdzIGZpbmUsXG4gICAgICAvLyBidXQgaWYgaXQncyAncXVldWVkJywgdGhhdCBtZWFucyB3ZSBuZWVkIHRvIGRlcGxveSBhZ2FpblxuICAgICAgd2hpbGUgKChsYXRjaCBhcyAnZGVwbG95aW5nJyB8ICdxdWV1ZWQnKSA9PT0gJ3F1ZXVlZCcpIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCBkb2Vzbid0IHJlYWxpemUgbGF0Y2ggY2FuIGNoYW5nZSBiZXR3ZWVuICdhd2FpdHMnIMKvXFxfKOODhClfL8KvLFxuICAgICAgICAvLyBhbmQgdGhpbmtzIHRoZSBhYm92ZSAnd2hpbGUnIGNvbmRpdGlvbiBpcyBhbHdheXMgJ2ZhbHNlJyB3aXRob3V0IHRoZSBjYXN0XG4gICAgICAgIGxhdGNoID0gJ2RlcGxveWluZyc7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIFwiW1NhbmRib3hdIERldGVjdGVkIGZpbGUgY2hhbmdlcyB3aGlsZSBwcmV2aW91cyBkZXBsb3ltZW50IHdhcyBpbiBwcm9ncmVzcy4gSW52b2tpbmcgJ3NhbmRib3gnIGFnYWluXCJcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgdGhpcy5kZXBsb3kob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBsYXRjaCA9ICdvcGVuJztcbiAgICAgIHRoaXMuZW1pdFdhdGNoaW5nKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLndhdGNoZXJTdWJzY3JpcHRpb24gPSBhd2FpdCBwYXJjZWxXYXRjaGVyLnN1YnNjcmliZShcbiAgICAgIG9wdGlvbnMuZGlyID8/ICcuL2FtcGxpZnknLFxuICAgICAgYXN5bmMgKF8sIGV2ZW50cykgPT4ge1xuICAgICAgICAvLyBMb2cgYW5kIHRyYWNrIGZpbGUgY2hhbmdlcy5cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgZXZlbnRzLm1hcCgoeyB0eXBlOiBldmVudE5hbWUsIHBhdGggfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5maWxlc0NoYW5nZXNUcmFja2VyLnRyYWNrRmlsZUNoYW5nZShwYXRoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICBgW1NhbmRib3hdIFRyaWdnZXJlZCBkdWUgdG8gYSBmaWxlICR7ZXZlbnROYW1lfSBldmVudDogJHtwYXRofWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGxhdGNoID09PSAnb3BlbicpIHtcbiAgICAgICAgICBhd2FpdCBkZXBsb3lBbmRXYXRjaCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoaXMgbWVhbnMgbGF0Y2ggaXMgZWl0aGVyICdkZXBsb3lpbmcnIG9yICdxdWV1ZWQnXG4gICAgICAgICAgbGF0Y2ggPSAncXVldWVkJztcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICdbU2FuZGJveF0gUHJldmlvdXMgZGVwbG95bWVudCBpcyBzdGlsbCBpbiBwcm9ncmVzcy4gJyArXG4gICAgICAgICAgICAgICdXaWxsIHF1ZXVlIGZvciBhbm90aGVyIGRlcGxveW1lbnQgYWZ0ZXIgdGhpcyBvbmUgZmluaXNoZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWdub3JlOiB0aGlzLm91dHB1dEZpbGVzRXhjbHVkZWRGcm9tV2F0Y2guY29uY2F0KFxuICAgICAgICAgIC4uLihvcHRpb25zLmV4Y2x1ZGUgPz8gW10pXG4gICAgICAgICksXG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIFN0YXJ0IHRoZSBmaXJzdCBmdWxsIGRlcGxveW1lbnQgd2l0aG91dCB3YWl0aW5nIGZvciBhIGZpbGUgY2hhbmdlXG4gICAgYXdhaXQgZGVwbG95QW5kV2F0Y2goKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIHN0b3AgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc29sZS5kZWJ1ZyhgW1NhbmRib3hdIFNodXR0aW5nIGRvd25gKTtcbiAgICAvLyBjYW4gYmUgdW5kZWZpbmVkIGlmIGNvbW1hbmQgZXhpdHMgYmVmb3JlIHN1YnNjcmlwdGlvblxuICAgIGF3YWl0IHRoaXMud2F0Y2hlclN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIGRlbGV0ZSA9IGFzeW5jIChvcHRpb25zOiBTYW5kYm94RGVsZXRlT3B0aW9ucykgPT4ge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgJ1tTYW5kYm94XSBEZWxldGluZyBhbGwgdGhlIHJlc291cmNlcyBpbiB0aGUgc2FuZGJveCBlbnZpcm9ubWVudC4uLidcbiAgICApO1xuICAgIGF3YWl0IHRoaXMuZXhlY3V0b3IuZGVzdHJveShcbiAgICAgIGF3YWl0IHRoaXMuYmFja2VuZElkU2FuZGJveFJlc29sdmVyKG9wdGlvbnMubmFtZSlcbiAgICApO1xuICAgIHRoaXMuZW1pdCgnc3VjY2Vzc2Z1bERlbGV0aW9uJyk7XG4gICAgY29uc29sZS5sb2coJ1tTYW5kYm94XSBGaW5pc2hlZCBkZWxldGluZy4nKTtcbiAgfTtcblxuICBwcml2YXRlIHNob3VsZFZhbGlkYXRlQXBwU291cmNlcyA9ICgpOiBib29sZWFuID0+IHtcbiAgICBjb25zdCBzbmFwc2hvdCA9IHRoaXMuZmlsZXNDaGFuZ2VzVHJhY2tlci5nZXRBbmRSZXNldFNuYXBzaG90KCk7XG4gICAgLy8gaWYgemVybyBmaWxlcyBjaGFuZ2VkIHRoaXMgaW5kaWNhdGVzIGluaXRpYWwgZGVwbG95bWVudFxuICAgIGNvbnN0IHNob3VsZFZhbGlkYXRlT25Db2xkU3RhcnQgPVxuICAgICAgc25hcHNob3QuaGFkVHlwZVNjcmlwdEZpbGVzQXRTdGFydCAmJlxuICAgICAgIXNuYXBzaG90LmRpZEFueUZpbGVDaGFuZ2VTaW5jZVN0YXJ0O1xuICAgIHJldHVybiAoXG4gICAgICBzaG91bGRWYWxpZGF0ZU9uQ29sZFN0YXJ0IHx8XG4gICAgICBzbmFwc2hvdC5kaWRBbnlUeXBlU2NyaXB0RmlsZUNoYW5nZVNpbmNlTGFzdFNuYXBzaG90XG4gICAgKTtcbiAgfTtcblxuICBwcml2YXRlIGRlcGxveSA9IGFzeW5jIChvcHRpb25zOiBTYW5kYm94T3B0aW9ucykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZXBsb3lSZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dG9yLmRlcGxveShcbiAgICAgICAgYXdhaXQgdGhpcy5iYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXIob3B0aW9ucy5uYW1lKSxcbiAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gcGFzcyB0aGlzIGFzIGNhbGxiYWNrIHNvIHRoYXQgZGVib3VuY2UgZG9lc1xuICAgICAgICAvLyBub3QgcmVzZXQgdHJhY2tlciBwcmVtYXR1cmVseVxuICAgICAgICB0aGlzLnNob3VsZFZhbGlkYXRlQXBwU291cmNlc1xuICAgICAgKTtcbiAgICAgIGNvbnNvbGUuZGVidWcoJ1tTYW5kYm94XSBSdW5uaW5nIHN1Y2Nlc3NmdWxEZXBsb3ltZW50IGV2ZW50IGhhbmRsZXJzJyk7XG4gICAgICB0aGlzLmVtaXQoJ3N1Y2Nlc3NmdWxEZXBsb3ltZW50JywgZGVwbG95UmVzdWx0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gUHJpbnQgdGhlIG1lYW5pbmdmdWwgbWVzc2FnZVxuICAgICAgY29uc29sZS5sb2codGhpcy5nZXRFcnJvck1lc3NhZ2UoZXJyb3IpKTtcbiAgICAgIHRoaXMuZW1pdCgnZmFpbGVkRGVwbG95bWVudCcsIGVycm9yKTtcblxuICAgICAgLy8gSWYgdGhlIGVycm9yIGlzIGJlY2F1c2Ugb2YgYSBub24tYWxsb3dlZCBkZXN0cnVjdGl2ZSBjaGFuZ2Ugc3VjaCBhc1xuICAgICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0Nsb3VkRm9ybWF0aW9uL2xhdGVzdC9Vc2VyR3VpZGUvYXdzLXJlc291cmNlLWNvZ25pdG8tdXNlcnBvb2wuaHRtbCNjZm4tY29nbml0by11c2VycG9vbC1hbGlhc2F0dHJpYnV0ZXNcbiAgICAgIC8vIG9mZmVyIHRvIHJlY3JlYXRlIHRoZSBzYW5kYm94IG9yIHJldmVydCB0aGUgY2hhbmdlXG4gICAgICBpZiAoXG4gICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnVXBkYXRlTm90U3VwcG9ydGVkJylcbiAgICAgICkge1xuICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZVVuc3VwcG9ydGVkRGVzdHJ1Y3RpdmVDaGFuZ2VzKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgLy8gZWxzZSBkbyBub3QgcHJvcGFnYXRlIGFuZCBsZXQgdGhlIHNhbmRib3ggY29udGludWUgdG8gcnVuXG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgcmVzZXQgPSBhc3luYyAob3B0aW9uczogU2FuZGJveE9wdGlvbnMpID0+IHtcbiAgICBhd2FpdCB0aGlzLmRlbGV0ZSh7IG5hbWU6IG9wdGlvbnMubmFtZSB9KTtcbiAgICBhd2FpdCB0aGlzLnN0YXJ0KG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBKdXN0IGEgc2hvcnRoYW5kIGNvbnNvbGUgbG9nIHRvIGluZGljYXRlIHdoZW5ldmVyIHdhdGNoZXIgaXMgZ29pbmcgaWRsZVxuICAgKi9cbiAgcHJpdmF0ZSBlbWl0V2F0Y2hpbmcgPSAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coYFtTYW5kYm94XSBXYXRjaGluZyBmb3IgZmlsZSBjaGFuZ2VzLi4uYCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlYWRzIGFuZCBwYXJzZXMgLmdpdGlnbm9yZSBmaWxlIGFuZCByZXR1cm5zIHRoZSBsaXN0IG9mIHBhdGhzXG4gICAqL1xuICBwcml2YXRlIGdldEdpdElnbm9yZWRQYXRocyA9ICgpID0+IHtcbiAgICBjb25zdCBnaXRJZ25vcmVGaWxlUGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnLmdpdGlnbm9yZScpO1xuICAgIGlmIChmcy5leGlzdHNTeW5jKGdpdElnbm9yZUZpbGVQYXRoKSkge1xuICAgICAgcmV0dXJuIHBhcnNlR2l0SWdub3JlXG4gICAgICAgIC5wYXJzZShnaXRJZ25vcmVGaWxlUGF0aClcbiAgICAgICAgLnBhdHRlcm5zLm1hcCgocGF0dGVybjogc3RyaW5nKSA9PlxuICAgICAgICAgIHBhdHRlcm4uc3RhcnRzV2l0aCgnLycpID8gcGF0dGVybi5zdWJzdHJpbmcoMSkgOiBwYXR0ZXJuXG4gICAgICAgIClcbiAgICAgICAgLmZpbHRlcigocGF0dGVybjogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgaWYgKHBhdHRlcm4uc3RhcnRzV2l0aCgnIScpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgYFtTYW5kYm94XSBQYXR0ZXJuICR7cGF0dGVybn0gZm91bmQgaW4gLmdpdGlnbm9yZS4gXCIke3BhdHRlcm4uc3Vic3RyaW5nKFxuICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgKX1cIiB3aWxsIG5vdCBiZSB3YXRjaGVkIGlmIG90aGVyIHBhdHRlcm5zIGluIC5naXRpZ25vcmUgYXJlIGV4Y2x1ZGluZyBpdC5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gcmVnaW9uIGhhcyBiZWVuIGJvb3RzdHJhcHBlZCB3aXRoID49IG1pbiB2ZXJzaW9uIHVzaW5nIENGTiBkZXNjcmliZVN0YWNrcyB3aXRoIENES1Rvb2xLaXQuXG4gICAqIEByZXR1cm5zIEEgQm9vbGVhbiB0aGF0IHJlcHJlc2VudHMgaWYgcmVnaW9uIGhhcyBiZWVuIGJvb3RzdHJhcHBlZC5cbiAgICovXG4gIHByaXZhdGUgaXNCb290c3RyYXBwZWQgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgU3RhY2tzOiBzdGFja3MgfSA9IGF3YWl0IHRoaXMuY2ZuQ2xpZW50LnNlbmQoXG4gICAgICAgIG5ldyBEZXNjcmliZVN0YWNrc0NvbW1hbmQoe1xuICAgICAgICAgIFN0YWNrTmFtZTogQ0RLX0JPT1RTVFJBUF9TVEFDS19OQU1FLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGJvb3RzdHJhcFZlcnNpb24gPSBzdGFja3M/LlswXT8uT3V0cHV0cz8uZmluZChcbiAgICAgICAgKG91dHB1dCkgPT4gb3V0cHV0Lk91dHB1dEtleSA9PT0gQ0RLX0JPT1RTVFJBUF9WRVJTSU9OX0tFWVxuICAgICAgKT8uT3V0cHV0VmFsdWU7XG4gICAgICBpZiAoXG4gICAgICAgICFib290c3RyYXBWZXJzaW9uIHx8XG4gICAgICAgIE51bWJlcihib290c3RyYXBWZXJzaW9uKSA8IENES19NSU5fQk9PVFNUUkFQX1ZFUlNJT05cbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGUgJiZcbiAgICAgICAgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICdtZXNzYWdlJyBpbiBlICYmXG4gICAgICAgIHR5cGVvZiBlLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIGUubWVzc2FnZS5pbmNsdWRlcygnZG9lcyBub3QgZXhpc3QnKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGFyZSB1bmFibGUgdG8gZ2V0IHRoZSBzdGFjayBpbmZvIGR1ZSB0byBvdGhlciByZWFzb25zKEFjY2Vzc0RlbmllZCksIHdlIGZhaWwgZmFzdC5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBwcmludGFibGUgZXJyb3IgbWVzc2FnZSBmcm9tIHRoZSB0aHJvd24gZXJyb3JcbiAgICovXG4gIHByaXZhdGUgZ2V0RXJyb3JNZXNzYWdlID0gKGVycm9yOiB1bmtub3duKSA9PiB7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuXG4gICAgICAvLyBBZGQgdGhlIGRvd25zdHJlYW0gZXhjZXB0aW9uXG4gICAgICBpZiAoZXJyb3IuY2F1c2UgJiYgZXJyb3IuY2F1c2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX1cXG5DYXVzZWQgQnk6ICR7XG4gICAgICAgICAgZXJyb3IuY2F1c2UgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICAgICAgPyBlcnJvci5jYXVzZS5tZXNzYWdlXG4gICAgICAgICAgICA6IFN0cmluZyhlcnJvci5jYXVzZSlcbiAgICAgICAgfWA7XG4gICAgICB9XG4gICAgfSBlbHNlIG1lc3NhZ2UgPSBTdHJpbmcoZXJyb3IpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlVW5zdXBwb3J0ZWREZXN0cnVjdGl2ZUNoYW5nZXMgPSBhc3luYyAoXG4gICAgb3B0aW9uczogU2FuZGJveE9wdGlvbnNcbiAgKSA9PiB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgICdbU2FuZGJveF0gV2UgY2Fubm90IGRlcGxveSB5b3VyIG5ldyBjaGFuZ2VzLiBZb3UgY2FuIGVpdGhlciByZXZlcnQgdGhlbSBvciByZWNyZWF0ZSB5b3VyIHNhbmRib3ggd2l0aCB0aGUgbmV3IGNoYW5nZXMgKGRlbGV0aW5nIGFsbCB1c2VyIGRhdGEpJ1xuICAgICk7XG4gICAgLy8gb2ZmZXIgdG8gcmVjcmVhdGUgdGhlIHNhbmRib3ggd2l0aCBuZXcgcHJvcGVydGllc1xuICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IEFtcGxpZnlQcm9tcHRlci55ZXNPck5vKHtcbiAgICAgIG1lc3NhZ2U6XG4gICAgICAgICdXb3VsZCB5b3UgbGlrZSB0byByZWNyZWF0ZSB5b3VyIHNhbmRib3ggKGRlbGV0aW5nIGFsbCB1c2VyIGRhdGEpPycsXG4gICAgICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICAgIH0pO1xuICAgIGlmIChhbnN3ZXIpIHtcbiAgICAgIGF3YWl0IHRoaXMuc3RvcCgpO1xuICAgICAgYXdhaXQgdGhpcy5yZXNldChvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gZWxzZSBsZXQgdGhlIHNhbmRib3ggY29udGludWUgc28gY3VzdG9tZXJzIGNhbiByZXZlcnQgdGhlaXIgY2hhbmdlc1xuICB9O1xufVxuIl19