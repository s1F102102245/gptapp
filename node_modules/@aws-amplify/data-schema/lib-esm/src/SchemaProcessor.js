"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processSchema = void 0;
const ModelField_1 = require("./ModelField");
const ModelRelationalField_1 = require("./ModelRelationalField");
const Authorization_1 = require("./Authorization");
const CustomOperation_1 = require("./CustomOperation");
function isInternalModel(model) {
    if (model.data &&
        !isCustomType(model) &&
        !isCustomOperation(model)) {
        return true;
    }
    return false;
}
function isEnumType(data) {
    if (data?.type === 'enum') {
        return true;
    }
    return false;
}
function isCustomType(data) {
    if (data?.data?.type === 'customType') {
        return true;
    }
    return false;
}
function isCustomOperation(type) {
    if (CustomOperation_1.CustomOperationNames.includes(type?.data?.typeName)) {
        return true;
    }
    return false;
}
function isModelFieldDef(data) {
    return data?.fieldType === 'model';
}
function isScalarFieldDef(data) {
    return data?.fieldType !== 'model';
}
function isRefFieldDef(data) {
    return data?.type === 'ref';
}
function isModelField(field) {
    return isModelFieldDef(field.data);
}
function isScalarField(field) {
    return isScalarFieldDef(field.data);
}
function isRefField(field) {
    return isRefFieldDef(field.data);
}
function scalarFieldToGql(fieldDef, identifier) {
    const { fieldType, required, array, arrayRequired, default: _default, } = fieldDef;
    let field = fieldType;
    if (identifier !== undefined) {
        field += '!';
        if (identifier.length > 1) {
            const [_pk, ...sk] = identifier;
            field += ` @primaryKey(sortKeyFields: ${JSON.stringify(sk)})`;
        }
        else {
            field += ' @primaryKey';
        }
        return field;
    }
    if (required === true) {
        field += '!';
    }
    if (array) {
        field = `[${field}]`;
        if (arrayRequired === true) {
            field += '!';
        }
    }
    if (_default !== undefined) {
        field += ` @default(value: "${_default?.toString()}")`;
    }
    return field;
}
function modelFieldToGql(fieldDef) {
    const { type, relatedModel, array, relationName, valueRequired, arrayRequired, } = fieldDef;
    let field = relatedModel;
    if (valueRequired === true) {
        field += '!';
    }
    if (array) {
        field = `[${field}]`;
    }
    if (arrayRequired === true) {
        field += '!';
    }
    field += ` @${type}`;
    // TODO: accept other relationship options e.g. `fields`
    if (type === 'manyToMany') {
        field += `(relationName: "${relationName}")`;
    }
    return field;
}
function refFieldToGql(fieldDef) {
    const { link, required } = fieldDef;
    let field = link;
    if (required === true) {
        field += '!';
    }
    // if (array) {
    //   field = `[${field}]`;
    // }
    // if (arrayRequired === true) {
    //   field += '!';
    // }
    return field;
}
function customOperationToGql(typeName, typeDef) {
    const { arguments: fieldArgs, returnType, authorization, functionRef, } = typeDef.data;
    const { authString } = calculateAuth(authorization);
    const resolvedArg = refFieldToGql(returnType.data);
    let sig = typeName;
    let implicitModels = [];
    if (Object.keys(fieldArgs).length > 0) {
        const { gqlFields, models } = processFields(fieldArgs, {});
        sig += `(${gqlFields.join(', ')})`;
        implicitModels = models;
    }
    const fnString = functionRef ? `@function(name: "${functionRef}") ` : '';
    const gqlField = `${sig}: ${resolvedArg} ${fnString}${authString}`;
    return { gqlField, models: implicitModels };
}
/**
 * Tests whether two ModelField definitions are in conflict.
 *
 * This is a shallow check intended to catch conflicts between defined fields
 * and fields implied by authorization rules. Hence, it only compares type
 * and plurality.
 *
 * @param left
 * @param right
 * @returns
 */
function areConflicting(left, right) {
    // These are the only props we care about for this comparison, because the others
    // (required, arrayRequired, etc) are not specified on auth or FK directives.
    const relevantProps = ['array', 'fieldType'];
    for (const prop of relevantProps) {
        if (left.data[prop] !== right.data[prop]) {
            return true;
        }
    }
    return false;
}
/**
 * Merges one field defition object onto an existing one, performing
 * validation (conflict detection) along the way.
 *
 * @param existing An existing field map
 * @param additions A field map to merge in
 */
function addFields(existing, additions) {
    for (const [k, addition] of Object.entries(additions)) {
        if (!existing[k]) {
            existing[k] = addition;
        }
        else if (areConflicting(existing[k], addition)) {
            throw new Error(`Field ${k} defined twice with conflicting definitions.`);
        }
        else {
            // fields are defined on both sides, but match.
        }
    }
}
/**
 * Produces a new field definition object from every field definition object
 * given as an argument. Performs validation (conflict detection) as objects
 * are merged together.
 *
 * @param fieldsObjects A list of field definition objects to merge.
 * @returns
 */
function mergeFieldObjects(...fieldsObjects) {
    const result = {};
    for (const fields of fieldsObjects) {
        if (fields)
            addFields(result, fields);
    }
    return result;
}
/**
 * Given a list of authorization rules, produces a set of the implied owner and/or
 * group fields, along with the associated graphql `@auth` string directive.
 *
 * This is intended to be called for each model and field to collect the implied
 * fields and directives from that individual "item's" auth rules.
 *
 * The computed directives are intended to be appended to the graphql field definition.
 *
 * The computed fields are intended to be aggregated and injected per model.
 *
 * @param authorization A list of authorization rules.
 * @returns
 */
function calculateAuth(authorization) {
    const authFields = {};
    const rules = [];
    for (const entry of authorization) {
        const rule = (0, Authorization_1.accessData)(entry);
        const ruleParts = [];
        if (rule.strategy) {
            ruleParts.push([`allow: ${rule.strategy}`]);
        }
        else {
            return {
                authFields,
                authString: '',
            };
        }
        if (rule.provider) {
            ruleParts.push(`provider: ${rule.provider}`);
        }
        if (rule.operations) {
            ruleParts.push(`operations: [${rule.operations.join(', ')}]`);
        }
        if (rule.groupOrOwnerField) {
            // directive attribute, depending whether it's owner or group auth
            if (rule.strategy === 'groups') {
                // does this need to be escaped?
                ruleParts.push(`groupsField: "${rule.groupOrOwnerField}"`);
            }
            else {
                // does this need to be escaped?
                ruleParts.push(`ownerField: "${rule.groupOrOwnerField}"`);
            }
            // model field dep, type of which depends on whether multiple owner/group
            // is required.
            if (rule.multiOwner) {
                addFields(authFields, { [rule.groupOrOwnerField]: (0, ModelField_1.string)().array() });
            }
            else {
                addFields(authFields, { [rule.groupOrOwnerField]: (0, ModelField_1.string)() });
            }
        }
        if (rule.groups) {
            // does `group` need to be escaped?
            ruleParts.push(`groups: [${rule.groups.map((group) => `"${group}"`).join(', ')}]`);
        }
        // identityClaim
        if (rule.identityClaim) {
            // does this need to be escaped?
            ruleParts.push(`identityClaim: "${rule.identityClaim}"`);
        }
        // groupClaim
        if (rule.groupClaim) {
            // does this need to be escaped?
            ruleParts.push(`groupClaim: "${rule.groupClaim}"`);
        }
        rules.push(`{${ruleParts.join(', ')}}`);
    }
    const authString = rules.length > 0 ? `@auth(rules: [${rules.join(',\n  ')}])` : '';
    return { authString, authFields };
}
function capitalize(s) {
    return `${s[0].toUpperCase()}${s.slice(1)}`;
}
function uncapitalize(s) {
    return `${s[0].toLowerCase()}${s.slice(1)}`;
}
function fkName(model, field, identifier) {
    return `${uncapitalize(model)}${capitalize(field)}${capitalize(identifier)}`;
}
/**
 * Returns all explicitly defined and implied fields from a model.
 *
 * @param schema The schema the model is part of. Necessary to derive implied FK's.
 * @param model The model to extract fields from and derive fields for.
 * @returns
 */
const allImpliedFKs = (schema) => {
    const fks = {};
    function addFk({ onModel, asField, fieldDef, }) {
        fks[onModel] = fks[onModel] || {};
        fks[onModel][asField] = fieldDef;
    }
    // implied FK's
    for (const [modelName, typeDef] of Object.entries(schema.data.types)) {
        if (!isInternalModel(typeDef))
            continue;
        for (const [fieldName, fieldDef] of Object.entries(typeDef.data.fields)) {
            if (!isModelField(fieldDef))
                continue;
            const relatedModel = schema.data.types[fieldDef.data.relatedModel];
            switch (fieldDef.data.type) {
                case ModelRelationalField_1.ModelRelationshipTypes.hasOne:
                    for (const idField of relatedModel.data.identifier) {
                        addFk({
                            onModel: modelName,
                            asField: fkName(modelName, fieldName, idField),
                            fieldDef: {
                                data: {
                                    ...fieldDef.data,
                                    fieldType: relatedModel.data.fields[idField]?.data.fieldType ||
                                        ModelField_1.ModelFieldType.Id,
                                },
                            },
                        });
                    }
                    break;
                case ModelRelationalField_1.ModelRelationshipTypes.hasMany:
                    {
                        let authorization = [];
                        let required = false;
                        const [_belongsToName, belongsToDef] = Object.entries(relatedModel.data.fields).find(([_name, def]) => {
                            return (isModelField(def) &&
                                def.data.type === ModelRelationalField_1.ModelRelationshipTypes.belongsTo &&
                                def.data.relatedModel === fieldName);
                        }) || [];
                        if (belongsToDef && isModelField(belongsToDef)) {
                            authorization = belongsToDef.data.authorization;
                            required = belongsToDef.data.valueRequired;
                        }
                        for (const idField of typeDef.data.identifier) {
                            addFk({
                                onModel: fieldDef.data.relatedModel,
                                asField: fkName(modelName, fieldName, idField),
                                fieldDef: {
                                    data: {
                                        ...(typeDef.data.fields[idField]?.data ||
                                            (0, ModelField_1.id)().data),
                                        authorization,
                                        required,
                                    },
                                },
                            });
                        }
                    }
                    break;
                case ModelRelationalField_1.ModelRelationshipTypes.belongsTo:
                    {
                        // only create if corresponds to hasOne
                        const [_hasOneName, hasOneDef] = Object.entries(relatedModel.data.fields).find(([_name, def]) => {
                            return (isModelField(def) &&
                                def.data.type === ModelRelationalField_1.ModelRelationshipTypes.hasOne &&
                                def.data.relatedModel === modelName);
                        }) || [];
                        if (hasOneDef && isModelField(hasOneDef)) {
                            for (const idField of relatedModel.data.identifier) {
                                addFk({
                                    onModel: modelName,
                                    asField: fkName(modelName, fieldName, idField),
                                    fieldDef: {
                                        data: {
                                            ...typeDef.data,
                                            fieldType: relatedModel.data.fields[idField]?.data.fieldType ||
                                                ModelField_1.ModelFieldType.Id,
                                        },
                                    },
                                });
                            }
                        }
                    }
                    break;
                case ModelRelationalField_1.ModelRelationshipTypes.manyToMany:
                    // pretty sure there's nothing to do here.
                    // the implicit join table already has everything, AFAIK.
                    break;
                default:
                // nothing to do.
            }
        }
    }
    return fks;
};
/**
 * Determines if implicit date fields are in effect for a given model. If they are,
 * returns those implicit fields.
 *
 * NOTE: For now, we *only* support the default implicit fields.
 *
 * @param _model Model to find date fields for.
 */
const implicitTimestampFields = (_model) => {
    return {
        createdAt: (0, ModelField_1.datetime)().required(),
        updatedAt: (0, ModelField_1.datetime)().required(),
    };
};
/**
 * Generates default Pk fields for a model, based on identifier designation.
 *
 * The fields from this function are just default values. They should be overridden
 * by ID field definitions that are explicit in the model.
 *
 * @param _model Model to find PK fields for.
 */
const idFields = (model) => {
    const fields = {};
    for (const fieldName of model.data.identifier) {
        fields[fieldName] = (0, ModelField_1.id)().required();
    }
    return fields;
};
function processFieldLevelAuthRules(fields, authFields) {
    const fieldLevelAuthRules = {};
    for (const [fieldName, fieldDef] of Object.entries(fields)) {
        const { authString, authFields: fieldAuthField } = calculateAuth(fieldDef?.data?.authorization || []);
        if (authString)
            fieldLevelAuthRules[fieldName] = authString;
        if (fieldAuthField) {
            addFields(authFields, fieldAuthField);
        }
    }
    return fieldLevelAuthRules;
}
function processFields(fields, fieldLevelAuthRules, identifier, partitionKey) {
    const gqlFields = [];
    const models = [];
    for (const [fieldName, fieldDef] of Object.entries(fields)) {
        const fieldAuth = fieldLevelAuthRules[fieldName]
            ? ` ${fieldLevelAuthRules[fieldName]}`
            : '';
        if (isModelField(fieldDef)) {
            gqlFields.push(`${fieldName}: ${modelFieldToGql(fieldDef.data)}${fieldAuth}`);
        }
        else if (isScalarField(fieldDef)) {
            if (fieldName === partitionKey) {
                gqlFields.push(`${fieldName}: ${scalarFieldToGql(fieldDef.data, identifier)}${fieldAuth}`);
            }
            else if (isRefField(fieldDef)) {
                gqlFields.push(`${fieldName}: ${refFieldToGql(fieldDef.data)}${fieldAuth}`);
            }
            else if (isEnumType(fieldDef)) {
                const enumName = capitalize(fieldName);
                models.push([enumName, fieldDef]);
                gqlFields.push(`${fieldName}: ${enumName}`);
            }
            else if (isCustomType(fieldDef)) {
                const customTypeName = capitalize(fieldName);
                models.push([customTypeName, fieldDef]);
                gqlFields.push(`${fieldName}: ${customTypeName}`);
            }
            else {
                gqlFields.push(`${fieldName}: ${scalarFieldToGql(fieldDef.data)}${fieldAuth}`);
            }
        }
        else {
            throw new Error(`Unexpected field definition: ${fieldDef}`);
        }
    }
    return { gqlFields, models };
}
const schemaPreprocessor = (schema) => {
    const gqlModels = [];
    const customQueries = [];
    const customMutations = [];
    const customSubscriptions = [];
    const fkFields = allImpliedFKs(schema);
    const topLevelTypes = Object.entries(schema.data.types);
    for (const [typeName, typeDef] of topLevelTypes) {
        if (!isInternalModel(typeDef)) {
            if (isEnumType(typeDef)) {
                const enumType = `enum ${typeName} {\n  ${typeDef.values.join('\n  ')}\n}`;
                gqlModels.push(enumType);
            }
            else if (isCustomType(typeDef)) {
                const fields = typeDef.data.fields;
                const authString = '';
                const authFields = {};
                const fieldLevelAuthRules = processFieldLevelAuthRules(fields, authFields);
                const { gqlFields, models } = processFields(fields, fieldLevelAuthRules);
                topLevelTypes.push(...models);
                const joined = gqlFields.join('\n  ');
                const model = `type ${typeName} ${authString}\n{\n  ${joined}\n}`;
                gqlModels.push(model);
            }
            else if (isCustomOperation(typeDef)) {
                const { typeName: opType } = typeDef.data;
                const { gqlField, models } = customOperationToGql(typeName, typeDef);
                topLevelTypes.push(...models);
                switch (opType) {
                    case 'Query':
                        customQueries.push(gqlField);
                        break;
                    case 'Mutation':
                        customMutations.push(gqlField);
                        break;
                    case 'Subscription':
                        customSubscriptions.push(gqlField);
                        break;
                    default:
                        break;
                }
            }
        }
        else {
            const fields = mergeFieldObjects(typeDef.data.fields, fkFields[typeName]);
            const identifier = typeDef.data.identifier;
            const [partitionKey] = identifier;
            const mostRelevantAuthRules = typeDef.data.authorization.length > 0
                ? typeDef.data.authorization
                : schema.data.authorization;
            const { authString, authFields } = calculateAuth(mostRelevantAuthRules);
            if (authString == '') {
                throw new Error(`Model \`${typeName}\` is missing authorization rules. Add global rules to the schema or ensure every model has its own rules.`);
            }
            const fieldLevelAuthRules = processFieldLevelAuthRules(fields, authFields);
            const { gqlFields, models } = processFields({
                // ID fields are not merged outside `mergeFieldObjects` to skip
                // validation, because the `identifer()` method doesn't specify or
                // care what the underlying field type is. We should always just defer
                // to whatever is explicitly defined if there's an overlap.
                ...idFields(typeDef),
                ...mergeFieldObjects(fields, authFields, implicitTimestampFields(typeDef)),
            }, fieldLevelAuthRules, identifier, partitionKey);
            topLevelTypes.push(...models);
            const joined = gqlFields.join('\n  ');
            const model = `type ${typeName} @model ${authString}\n{\n  ${joined}\n}`;
            gqlModels.push(model);
        }
    }
    const customOperations = {
        queries: customQueries,
        mutations: customMutations,
        subscriptions: customSubscriptions,
    };
    gqlModels.push(...generateCustomOperationTypes(customOperations));
    const processedSchema = gqlModels.join('\n\n');
    return processedSchema;
};
function generateCustomOperationTypes({ queries, mutations, subscriptions, }) {
    const types = [];
    if (mutations.length > 0) {
        types.push(`type Mutation {\n  ${mutations.join('\n  ')}\n}`);
    }
    if (queries.length > 0) {
        types.push(`type Query {\n  ${queries.join('\n  ')}\n}`);
    }
    if (subscriptions.length > 0) {
        types.push(`type Subscription {\n  ${subscriptions.join('\n  ')}\n}`);
    }
    return types;
}
/**
 * Returns API definition from ModelSchema or string schema
 * @param arg - { schema }
 * @returns DerivedApiDefinition that conforms to IAmplifyGraphqlDefinition
 */
function processSchema(arg) {
    const schema = schemaPreprocessor(arg.schema);
    return { schema, functionSlots: [] };
}
exports.processSchema = processSchema;
