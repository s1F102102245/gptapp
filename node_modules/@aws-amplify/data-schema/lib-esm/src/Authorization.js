"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.accessData = exports.allow = exports.Operations = exports.Strategies = exports.CustomProviders = exports.GroupProviders = exports.OwnerProviders = exports.PrivateProviders = exports.PublicProviders = exports.Providers = void 0;
const __data = Symbol('data');
/**
 * All possible providers.
 *
 * This list should not be used if you need to restrict available providers
 * according to an auth strategcy. E.g., `public` auth can only be facilitated
 * by `apiKey` and `iam` providers.
 */
exports.Providers = [
    'apiKey',
    'iam',
    'userPools',
    'oidc',
    'function',
];
/**
 * The subset of auth providers that can facilitate `public` auth.
 */
exports.PublicProviders = ['apiKey', 'iam'];
/**
 * The subset of auth providers that can facilitate `private` auth.
 */
exports.PrivateProviders = ['userPools', 'oidc', 'iam'];
/**
 * The subset of auth providers that can facilitate `owner` auth.
 */
exports.OwnerProviders = ['userPools', 'oidc'];
/**
 * The subset of auth providers that can facilitate `group` auth.
 */
exports.GroupProviders = ['userPools', 'oidc'];
/**
 * The subset of auth providers that can facilitate `custom` auth.
 */
exports.CustomProviders = ['function'];
exports.Strategies = [
    'public',
    'private',
    'owner',
    'groups',
    'custom',
];
/**
 * The operations that can be performed against an API.
 */
exports.Operations = [
    'create',
    'update',
    'delete',
    'read',
    'get',
    'list',
    'sync',
    'listen',
    'search',
];
/**
 * Creates a shallow copy of an object with an individual field pruned away.
 *
 * @param original The original object to prune.
 * @param without The field to prune.
 * @returns The pruned object.
 */
function omit(original, without) {
    const pruned = { ...original };
    delete pruned[without];
    return pruned;
}
function to(operations) {
    this[__data].operations = operations;
    return omit(this, 'to');
}
function inField(field) {
    this[__data].groupOrOwnerField = field;
    const built = omit(this, 'inField');
    return built;
}
/**
 * Specifies a property of the identity JWT to use in place of `sub::username`
 * as the value to match against the owner field for authorization.
 *
 * @param this Authorization object to operate against.
 * @param property A property of identity JWT.
 * @returns A copy of the Authorization object with the claim attached.
 */
function identityClaim(property) {
    this[__data].identityClaim = property;
    return omit(this, 'identityClaim');
}
function withClaimIn(property) {
    this[__data].groupClaim = property;
    return omit(this, 'withClaimIn');
}
function validateProvider(needle, haystack) {
    if (needle && !haystack.includes(needle)) {
        throw new Error(`Invalid provider (${needle}) given!`);
    }
}
function authData(defaults, builderMethods) {
    return {
        [__data]: {
            strategy: 'public',
            provider: undefined,
            operations: undefined,
            groupOrOwnerField: undefined,
            multiOwner: false,
            identityClaim: undefined,
            groups: undefined,
            ...defaults,
        },
        ...builderMethods,
    };
}
/**
 * Defines an authorization rule for your data models and fields. First choose an authorization strategy (`public`,
 * `private`, `owner`, `group`, or `custom`), then choose an auth provider (`apiKey`, `iam`, `userPools`, `oidc`, or `function`)
 * and optionally use `.to(...)` to specify the operations that can be performed against your data models and fields.
 */
exports.allow = {
    /**
     * Authorize unauthenticated users. By default, `.public()` uses an API key based authorization. You can additionally
     * use `.public('iam')` to use IAM based authorization for unauthenticated users.
     * @param provider the authentication provider - supports "apiKey" or "iam" as valid providers
     * @returns an authorization rule for unauthenticated users
     */
    public(provider) {
        validateProvider(provider, exports.PublicProviders);
        return authData({
            strategy: 'public',
            provider,
        }, {
            to,
        });
    },
    /**
     * Authorize authenticated users. By default, `.private()` uses an Amazon Cognito user pool based authorization. You can additionally
     * use `.private("iam")` or `.private("oidc")` to use IAM or OIDC based authorization for authenticated users.
     * @param provider the authentication provider - supports "userPools", "iam", or "oidc"
     * @returns an authorization rule for authenticated users
     */
    private(provider) {
        validateProvider(provider, exports.PrivateProviders);
        return authData({
            strategy: 'private',
            provider,
        }, {
            to,
        });
    },
    /**
     * Authorize access on a per-user (owner) basis. By setting owner-based authorization, a new `owner: a.string()`
     * field will be added to the model to store which user "owns" the item. Upon item creation, the "owner field" is
     * auto-populated with the authenticated user's information. You can which field should be used as the owner field
     * by chaining the * `.inField(...)` method.
     *
     * By default, `.owner()` uses an Amazon Cognito user pool based authorization. You can additionally
     * use `.owner("oidc")` to use OIDC based authentication to designate the owner.
     *
     * To change the specific claim that should be used as the user identifier within the owner field, chain the
     * `.identityClaim(...)` method.
     *
     * @param provider the authentication provider - supports "userPools", "iam", or "oidc"
     * @returns an authorization rule for authenticated users
     */
    owner(provider) {
        validateProvider(provider, exports.OwnerProviders);
        return authData({
            strategy: 'owner',
            provider,
            groupOrOwnerField: 'owner',
        }, {
            to,
            inField,
            identityClaim,
        });
    },
    /**
     * Authorize access for multi-user / multi-owner access. By setting multi-owner-based authorization, a new `owners: a.string().array()`
     * field will be added to the model to store which users "own" the item. Upon item creation, the "owners field" is
     * auto-populated with the authenticated user's information. To grant other users access to the item, append their user identifier into the `owners` array.
     * You can which field should be used as the owners field by chaining the * `.inField(...)` method.
     *
     * By default, `.multipleOwners()` uses an Amazon Cognito user pool based authorization. You can additionally
     * use `.multipleOwners("oidc")` to use OIDC based authentication to designate the owner.
     *
     * To change the specific claim that should be used as the user identifier within the owners field, chain the
     * `.identityClaim(...)` method.
     *
     * @param provider the authentication provider - supports "userPools", "iam", or "oidc"
     * @returns an authorization rule for authenticated users
     */
    multipleOwners(provider) {
        validateProvider(provider, exports.OwnerProviders);
        return authData({
            strategy: 'owner',
            multiOwner: true,
            provider,
            groupOrOwnerField: 'owner',
        }, {
            to,
            inField,
            identityClaim,
        });
    },
    /**
     * Authorize a specific user group. Provide the name of the specific user group to have access.
     *
     * By default, `.specificGroup()` uses an Amazon Cognito user pool based authorization. You can additionally
     * use `.specificGroup("group-name", "oidc")` to use OIDC based authentication to designate the user group.
     *
     * To change the specific claim that should be used as the user group identifier, chain the
     * `.withClaimIn(...)` method.
     * @param group the name of the group to authorize
     * @param provider the authentication provider - supports "userPools" or "oidc"
     * @returns an authorization rule to grant access by a specific group
     */
    specificGroup(group, provider) {
        return authData({
            strategy: 'groups',
            provider,
            groups: [group],
        }, {
            to,
            withClaimIn,
        });
    },
    /**
     * Authorize multiple specific user groups. Provide the names of the specific user groups to have access.
     *
     * By default, `.specificGroups()` uses an Amazon Cognito user pool based authorization. You can additionally
     * use `.specificGroups(["group-a", "group-b"], "oidc")` to use OIDC based authentication to designate the user group.
     *
     * To change the specific claim that should be used as the user group identifier, chain the
     * `.withClaimIn(...)` method.
     * @param groups the names of the group to authorize defined as an array
     * @param provider the authentication provider - supports "userPools" or "oidc"
     * @returns an authorization rule to grant access by a specific group
     */
    specificGroups(groups, provider) {
        return authData({
            strategy: 'groups',
            provider,
            groups,
        }, {
            to,
            withClaimIn,
        });
    },
    /**
     * Authorize if a user is part of a group defined in a data model field.
     *
     * By default, `.groupDefinedIn()` uses an Amazon Cognito user pool based authorization. You can additionally
     * use `.groupDefinedIn("field-name", "oidc")` to use OIDC based authentication to designate the user group.
     *
     * To change the specific claim that should be used as the user group identifier within the groups field, chain the
     * `.withClaimIn(...)` method.
     * @param groupsField the field that should store the authorized user group information
     * @param provider the authentication provider - supports "userPools" or "oidc"
     * @returns an authorization rule to grant access by a specific group
     */
    groupDefinedIn(groupsField, provider) {
        return authData({
            strategy: 'groups',
            provider,
            groupOrOwnerField: groupsField,
        }, {
            to,
            withClaimIn,
        });
    },
    /**
     * Authorize if a user is part of a one of the groups defined in a data model field.
     *
     * By default, `.groupsDefinedIn()` uses an Amazon Cognito user pool based authorization. You can additionally
     * use `.groupsDefinedIn("field-name", "oidc")` to use OIDC based authentication to designate the user group.
     *
     * To change the specific claim that should be used as the user group identifier within the groups field, chain the
     * `.withClaimIn(...)` method.
     * @param groupsField the field that should store the list of authorized user groups
     * @param provider the authentication provider - supports "userPools" or "oidc"
     * @returns an authorization rule to grant access by a specific group
     */
    groupsDefinedIn(groupsField, provider) {
        return authData({
            strategy: 'groups',
            provider,
            groupOrOwnerField: groupsField,
            multiOwner: true,
        }, {
            to,
            withClaimIn,
        });
    },
    custom(provider) {
        return authData({
            strategy: 'custom',
            provider,
        }, {
            to,
        });
    },
};
const accessData = (authorization) => authorization[__data];
exports.accessData = accessData;
