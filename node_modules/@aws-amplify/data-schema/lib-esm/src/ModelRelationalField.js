"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.manyToMany = exports.belongsTo = exports.hasMany = exports.hasOne = exports.ModelRelationshipTypes = exports.__auth = void 0;
/**
 * Used to "attach" auth types to ModelField without exposing them on the builder.
 */
exports.__auth = Symbol('__auth');
const brandName = 'modelRelationalField';
var ModelRelationshipTypes;
(function (ModelRelationshipTypes) {
    ModelRelationshipTypes["hasOne"] = "hasOne";
    ModelRelationshipTypes["hasMany"] = "hasMany";
    ModelRelationshipTypes["belongsTo"] = "belongsTo";
    ModelRelationshipTypes["manyToMany"] = "manyToMany";
})(ModelRelationshipTypes || (exports.ModelRelationshipTypes = ModelRelationshipTypes = {}));
const arrayTypeRelationships = ['hasMany', 'manyToMany'];
const relationalModifiers = [
    'required',
    'arrayRequired',
    'valueRequired',
    'authorization',
];
const relationModifierMap = {
    belongsTo: ['authorization'],
    hasMany: ['arrayRequired', 'valueRequired', 'authorization'],
    hasOne: ['required', 'authorization'],
    manyToMany: ['arrayRequired', 'valueRequired', 'authorization'],
};
function _modelRelationalField(type, relatedModel, relationName) {
    const data = {
        relatedModel,
        type,
        fieldType: 'model',
        array: false,
        valueRequired: false,
        arrayRequired: false,
        relationName,
        authorization: [],
    };
    if (arrayTypeRelationships.includes(type)) {
        data.array = true;
    }
    const relationshipBuilderFunctions = {
        required() {
            data.arrayRequired = true;
            return this;
        },
        arrayRequired() {
            data.arrayRequired = true;
            return this;
        },
        valueRequired() {
            data.valueRequired = true;
            return this;
        },
        authorization(rules) {
            data.authorization = rules;
            return this;
        },
    };
    const builder = Object.fromEntries(relationModifierMap[type].map((key) => [
        key,
        relationshipBuilderFunctions[key],
    ]));
    return {
        ...builder,
        data,
    };
}
/**
 * Create a one-directional one-to-one relationship between two models using the `hasOne("MODEL_NAME")` method.
 * A hasOne relationship always uses a reference to the related model's identifier. Typically this is the `id` field
 * unless overwritten with the `identifier()` method.
 * @param relatedModel the name of the related model
 * @returns a one-to-one relationship definition
 */
function hasOne(relatedModel) {
    return _modelRelationalField(ModelRelationshipTypes.hasOne, relatedModel);
}
exports.hasOne = hasOne;
/**
 * Create a one-directional one-to-many relationship between two models using the `hasMany()` method.
 * @param relatedModel the name of the related model
 * @returns a one-to-many relationship definition
 */
function hasMany(relatedModel) {
    return _modelRelationalField(ModelRelationshipTypes.hasMany, relatedModel);
}
exports.hasMany = hasMany;
/**
 * Make a `hasOne()` or `hasMany()` relationship bi-directional using the `belongsTo()` method.
 * The belongsTo() method requires that a hasOne() or hasMany() relationship already exists from
 * parent to the related model.
 * @param relatedModel name of the related `.hasOne()` or `.hasMany()` model
 * @returns a belong-to relationship definition
 */
function belongsTo(relatedModel) {
    return _modelRelationalField(ModelRelationshipTypes.belongsTo, relatedModel);
}
exports.belongsTo = belongsTo;
/**
 * Create a many-to-many relationship between two models with the manyToMany() method.
 * Provide a common relationName on both models to join them into a many-to-many relationship.
 * Under the hood a many-to-many relationship is modeled with a "join table" with corresponding
 * `hasMany()` relationships between the two related models. You must set the same `manyToMany()`
 * field on both models of the relationship.
 * @param relatedModel name of the related model
 * @param opts pass in the `relationName` that will serve as the join table name for this many-to-many relationship
 * @returns a many-to-many relationship definition
 */
function manyToMany(relatedModel, opts) {
    return _modelRelationalField(ModelRelationshipTypes.manyToMany, relatedModel, opts.relationName);
}
exports.manyToMany = manyToMany;
