"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.constructDataSourceMap = exports.removeAmplifyInputDefinition = exports.sortTransformerPlugins = exports.matchEnumValueDirective = exports.matchArgumentDirective = exports.matchInputFieldDirective = exports.matchFieldDirective = exports.matchDirective = exports.makeSeenTransformationKey = void 0;
const graphql_1 = require("graphql");
const graphql_transformer_interfaces_1 = require("@aws-amplify/graphql-transformer-interfaces");
const lodash_1 = __importDefault(require("lodash"));
function makeSeenTransformationKey(directive, type, field, arg, index) {
    let key = '';
    if (directive && type && field && arg) {
        key = `${type.name.value}.${field.name.value}.${arg.name.value}@${directive.name.value}`;
    }
    if (directive && type && field) {
        key = `${type.name.value}.${field.name.value}@${directive.name.value}`;
    }
    else {
        key = `${type.name.value}@${directive.name.value}`;
    }
    if (index !== undefined) {
        key += `[${index}]`;
    }
    return key;
}
exports.makeSeenTransformationKey = makeSeenTransformationKey;
function matchDirective(definition, directive, node) {
    if (!directive) {
        return false;
    }
    if (definition.name.value !== directive.name.value) {
        return false;
    }
    let isValidLocation = false;
    for (const location of definition.locations) {
        switch (location.value) {
            case `SCHEMA`:
                isValidLocation = node.kind === graphql_1.Kind.SCHEMA_DEFINITION || isValidLocation;
                break;
            case `SCALAR`:
                isValidLocation = node.kind === graphql_1.Kind.SCALAR_TYPE_DEFINITION || isValidLocation;
                break;
            case `OBJECT`:
                isValidLocation = node.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION || isValidLocation;
                break;
            case `FIELD_DEFINITION`:
                isValidLocation = node.kind === graphql_1.Kind.FIELD_DEFINITION || isValidLocation;
                break;
            case `ARGUMENT_DEFINITION`:
                isValidLocation = node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || isValidLocation;
                break;
            case `INTERFACE`:
                isValidLocation = node.kind === graphql_1.Kind.INTERFACE_TYPE_DEFINITION || isValidLocation;
                break;
            case `UNION`:
                isValidLocation = node.kind === graphql_1.Kind.UNION_TYPE_DEFINITION || isValidLocation;
                break;
            case `ENUM`:
                isValidLocation = node.kind === graphql_1.Kind.ENUM_TYPE_DEFINITION || isValidLocation;
                break;
            case `ENUM_VALUE`:
                isValidLocation = node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION || isValidLocation;
                break;
            case `INPUT_OBJECT`:
                isValidLocation = node.kind === graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION || isValidLocation;
                break;
            case `INPUT_FIELD_DEFINITION`:
                isValidLocation = node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || isValidLocation;
                break;
            default:
                break;
        }
    }
    return isValidLocation;
}
exports.matchDirective = matchDirective;
function matchFieldDirective(definition, directive, node) {
    if (definition.name.value !== directive.name.value) {
        return false;
    }
    let isValidLocation = false;
    for (const location of definition.locations) {
        switch (location.value) {
            case `FIELD_DEFINITION`:
                isValidLocation = node.kind === graphql_1.Kind.FIELD_DEFINITION || isValidLocation;
                break;
            default:
                break;
        }
    }
    return isValidLocation;
}
exports.matchFieldDirective = matchFieldDirective;
function matchInputFieldDirective(definition, directive, node) {
    if (definition.name.value !== directive.name.value) {
        return false;
    }
    let isValidLocation = false;
    for (const location of definition.locations) {
        switch (location.value) {
            case `INPUT_FIELD_DEFINITION`:
                isValidLocation = node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || isValidLocation;
                break;
            default:
                break;
        }
    }
    return isValidLocation;
}
exports.matchInputFieldDirective = matchInputFieldDirective;
function matchArgumentDirective(definition, directive, node) {
    if (definition.name.value !== directive.name.value) {
        return false;
    }
    let isValidLocation = false;
    for (const location of definition.locations) {
        switch (location.value) {
            case `ARGUMENT_DEFINITION`:
                isValidLocation = node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || isValidLocation;
                break;
            default:
                break;
        }
    }
    return isValidLocation;
}
exports.matchArgumentDirective = matchArgumentDirective;
function matchEnumValueDirective(definition, directive, node) {
    if (definition.name.value !== directive.name.value) {
        return false;
    }
    let isValidLocation = false;
    for (const location of definition.locations) {
        switch (location.value) {
            case `ENUM_VALUE`:
                isValidLocation = node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION || isValidLocation;
                break;
            default:
                break;
        }
    }
    return isValidLocation;
}
exports.matchEnumValueDirective = matchEnumValueDirective;
function sortTransformerPlugins(plugins) {
    const SORT_ORDER = [
        graphql_transformer_interfaces_1.TransformerPluginType.DATA_SOURCE_PROVIDER,
        graphql_transformer_interfaces_1.TransformerPluginType.DATA_SOURCE_ENHANCER,
        graphql_transformer_interfaces_1.TransformerPluginType.GENERIC,
        graphql_transformer_interfaces_1.TransformerPluginType.AUTH,
    ];
    return plugins.sort((a, b) => {
        const aIdx = SORT_ORDER.indexOf(a.pluginType);
        const bIdx = SORT_ORDER.indexOf(b.pluginType);
        return aIdx - bIdx;
    });
}
exports.sortTransformerPlugins = sortTransformerPlugins;
const removeAmplifyInputDefinition = (schema) => {
    if (lodash_1.default.isEmpty(schema)) {
        return schema;
    }
    const { definitions, ...rest } = (0, graphql_1.parse)(schema);
    const isAmplifyInputNode = (definition) => definition.kind === 'InputObjectTypeDefinition' && definition.name.value === 'Amplify';
    return (0, graphql_1.print)({
        definitions: definitions.filter((definition) => !isAmplifyInputNode(definition)),
        ...rest,
    });
};
exports.removeAmplifyInputDefinition = removeAmplifyInputDefinition;
function constructDataSourceMap(schema, datasourceType) {
    const parsedSchema = (0, graphql_1.parse)(schema);
    const result = new Map();
    parsedSchema.definitions
        .filter((obj) => { var _a; return obj.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION && ((_a = obj.directives) === null || _a === void 0 ? void 0 : _a.some((dir) => dir.name.value === 'model')); })
        .forEach((type) => {
        result.set(type.name.value, datasourceType);
    });
    return result;
}
exports.constructDataSourceMap = constructDataSourceMap;
//# sourceMappingURL=utils.js.map