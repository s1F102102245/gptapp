import { DescribeStacksCommand, GetTemplateSummaryCommand, } from '@aws-sdk/client-cloudformation';
import { backendOutputStackMetadataSchema } from '@aws-amplify/backend-output-schemas';
import { BackendOutputClientError, BackendOutputClientErrorType, } from './index.js';
/**
 * Gets Amplify backend outputs from stack metadata and outputs
 */
export class StackMetadataBackendOutputRetrievalStrategy {
    cfnClient;
    stackNameResolver;
    /**
     * Instantiate with a CloudFormationClient and a StackNameResolver
     */
    constructor(cfnClient, stackNameResolver) {
        this.cfnClient = cfnClient;
        this.stackNameResolver = stackNameResolver;
    }
    /**
     * Resolves the stackName, then queries CFN for the stack metadata and outputs
     *
     * It combines the metadata and outputs to reconstruct the data object that was provided by the Amplify constructs when writing the output.
     * Except now the data contains the resolved values of the deployed resources rather than CFN references
     */
    fetchBackendOutput = async () => {
        const stackName = await this.stackNameResolver.resolveMainStackName();
        // GetTemplateSummary includes the template metadata as a string
        const templateSummary = await this.cfnClient.send(new GetTemplateSummaryCommand({ StackName: stackName }));
        if (typeof templateSummary.Metadata !== 'string') {
            throw new BackendOutputClientError(BackendOutputClientErrorType.METADATA_RETRIEVAL_ERROR, 'Stack template metadata is not a string');
        }
        const metadataObject = JSON.parse(templateSummary.Metadata);
        // parse and validate the metadata object
        const backendOutputMetadata = backendOutputStackMetadataSchema.parse(metadataObject);
        // DescribeStacks includes the template output
        const stackDescription = await this.cfnClient.send(new DescribeStacksCommand({ StackName: stackName }));
        const outputs = stackDescription?.Stacks?.[0]?.Outputs;
        if (outputs === undefined) {
            if (stackDescription.Stacks?.[0].StackStatus?.endsWith('_IN_PROGRESS')) {
                throw new BackendOutputClientError(BackendOutputClientErrorType.METADATA_RETRIEVAL_ERROR, `${stackDescription.Stacks?.[0].StackName ?? 'Stack'} is currently in ${stackDescription.Stacks?.[0].StackStatus}. Metadata will be available after stack completes processing.`);
            }
            throw new BackendOutputClientError(BackendOutputClientErrorType.METADATA_RETRIEVAL_ERROR, 'Stack outputs are undefined');
        }
        // outputs is a list of output entries. here we turn that into a Record<name, value> object
        const stackOutputRecord = outputs
            .filter((output) => !!output.OutputValue && !!output.OutputKey)
            .reduce((accumulator, outputEntry) => ({
            ...accumulator,
            // it's safe to disable this rule because we've already filtered out potentially undefined outputs
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            [outputEntry.OutputKey]: outputEntry.OutputValue,
        }), {});
        // now we iterate over the metadata entries and reconstruct the data object based on the stackOutputs that each construct package set
        const result = {};
        Object.entries(backendOutputMetadata).forEach(([outputKeyName, entry]) => {
            const outputData = entry.stackOutputs.reduce((accumulator, outputName) => {
                if (stackOutputRecord[outputName] === undefined) {
                    throw new BackendOutputClientError(BackendOutputClientErrorType.METADATA_RETRIEVAL_ERROR, `Output ${outputName} not found in stack`);
                }
                return {
                    ...accumulator,
                    [outputName]: stackOutputRecord[outputName],
                };
            }, {});
            result[outputKeyName] = {
                version: entry.version,
                payload: outputData,
            };
        });
        return result;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2tfbWV0YWRhdGFfb3V0cHV0X3JldHJpZXZhbF9zdHJhdGVneS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9zdGFja19tZXRhZGF0YV9vdXRwdXRfcmV0cmlldmFsX3N0cmF0ZWd5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFTCxxQkFBcUIsRUFDckIseUJBQXlCLEdBQzFCLE1BQU0sZ0NBQWdDLENBQUM7QUFNeEMsT0FBTyxFQUFFLGdDQUFnQyxFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDdkYsT0FBTyxFQUNMLHdCQUF3QixFQUN4Qiw0QkFBNEIsR0FDN0IsTUFBTSxZQUFZLENBQUM7QUFFcEI7O0dBRUc7QUFDSCxNQUFNLE9BQU8sMkNBQTJDO0lBT25DO0lBQ0E7SUFMbkI7O09BRUc7SUFDSCxZQUNtQixTQUErQixFQUMvQixpQkFBd0M7UUFEeEMsY0FBUyxHQUFULFNBQVMsQ0FBc0I7UUFDL0Isc0JBQWlCLEdBQWpCLGlCQUFpQixDQUF1QjtJQUN4RCxDQUFDO0lBRUo7Ozs7O09BS0c7SUFDSCxrQkFBa0IsR0FBRyxLQUFLLElBQTRCLEVBQUU7UUFDdEQsTUFBTSxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztRQUV0RSxnRUFBZ0U7UUFDaEUsTUFBTSxlQUFlLEdBQUcsTUFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FDL0MsSUFBSSx5QkFBeUIsQ0FBQyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUN4RCxDQUFDO1FBQ0YsSUFBSSxPQUFPLGVBQWUsQ0FBQyxRQUFRLEtBQUssUUFBUSxFQUFFO1lBQ2hELE1BQU0sSUFBSSx3QkFBd0IsQ0FDaEMsNEJBQTRCLENBQUMsd0JBQXdCLEVBQ3JELHlDQUF5QyxDQUMxQyxDQUFDO1NBQ0g7UUFFRCxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU1RCx5Q0FBeUM7UUFDekMsTUFBTSxxQkFBcUIsR0FDekIsZ0NBQWdDLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBRXpELDhDQUE4QztRQUM5QyxNQUFNLGdCQUFnQixHQUFHLE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQ2hELElBQUkscUJBQXFCLENBQUMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FDcEQsQ0FBQztRQUVGLE1BQU0sT0FBTyxHQUFHLGdCQUFnQixFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQztRQUN2RCxJQUFJLE9BQU8sS0FBSyxTQUFTLEVBQUU7WUFDekIsSUFBSSxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsUUFBUSxDQUFDLGNBQWMsQ0FBQyxFQUFFO2dCQUN0RSxNQUFNLElBQUksd0JBQXdCLENBQ2hDLDRCQUE0QixDQUFDLHdCQUF3QixFQUNyRCxHQUNFLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsSUFBSSxPQUM1QyxvQkFDRSxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUMvQixnRUFBZ0UsQ0FDakUsQ0FBQzthQUNIO1lBQ0QsTUFBTSxJQUFJLHdCQUF3QixDQUNoQyw0QkFBNEIsQ0FBQyx3QkFBd0IsRUFDckQsNkJBQTZCLENBQzlCLENBQUM7U0FDSDtRQUVELDJGQUEyRjtRQUMzRixNQUFNLGlCQUFpQixHQUFHLE9BQU87YUFDOUIsTUFBTSxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQzthQUM5RCxNQUFNLENBQ0wsQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzdCLEdBQUcsV0FBVztZQUNkLGtHQUFrRztZQUNsRyxvRUFBb0U7WUFDcEUsQ0FBQyxXQUFXLENBQUMsU0FBVSxDQUFDLEVBQUUsV0FBVyxDQUFDLFdBQVk7U0FDbkQsQ0FBQyxFQUNGLEVBQTRCLENBQzdCLENBQUM7UUFFSixxSUFBcUk7UUFDckksTUFBTSxNQUFNLEdBQWtCLEVBQUUsQ0FBQztRQUNqQyxNQUFNLENBQUMsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxhQUFhLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRTtZQUN2RSxNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FDMUMsQ0FBQyxXQUFXLEVBQUUsVUFBVSxFQUFFLEVBQUU7Z0JBQzFCLElBQUksaUJBQWlCLENBQUMsVUFBVSxDQUFDLEtBQUssU0FBUyxFQUFFO29CQUMvQyxNQUFNLElBQUksd0JBQXdCLENBQ2hDLDRCQUE0QixDQUFDLHdCQUF3QixFQUNyRCxVQUFVLFVBQVUscUJBQXFCLENBQzFDLENBQUM7aUJBQ0g7Z0JBQ0QsT0FBTztvQkFDTCxHQUFHLFdBQVc7b0JBQ2QsQ0FBQyxVQUFVLENBQUMsRUFBRSxpQkFBaUIsQ0FBQyxVQUFVLENBQUM7aUJBQzVDLENBQUM7WUFDSixDQUFDLEVBQ0QsRUFBNEIsQ0FDN0IsQ0FBQztZQUNGLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBRztnQkFDdEIsT0FBTyxFQUFFLEtBQUssQ0FBQyxPQUFPO2dCQUN0QixPQUFPLEVBQUUsVUFBVTthQUNwQixDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7UUFDSCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDLENBQUM7Q0FDSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENsb3VkRm9ybWF0aW9uQ2xpZW50LFxuICBEZXNjcmliZVN0YWNrc0NvbW1hbmQsXG4gIEdldFRlbXBsYXRlU3VtbWFyeUNvbW1hbmQsXG59IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQge1xuICBCYWNrZW5kT3V0cHV0LFxuICBCYWNrZW5kT3V0cHV0UmV0cmlldmFsU3RyYXRlZ3ksXG4gIE1haW5TdGFja05hbWVSZXNvbHZlcixcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsdWdpbi10eXBlcyc7XG5pbXBvcnQgeyBiYWNrZW5kT3V0cHV0U3RhY2tNZXRhZGF0YVNjaGVtYSB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9iYWNrZW5kLW91dHB1dC1zY2hlbWFzJztcbmltcG9ydCB7XG4gIEJhY2tlbmRPdXRwdXRDbGllbnRFcnJvcixcbiAgQmFja2VuZE91dHB1dENsaWVudEVycm9yVHlwZSxcbn0gZnJvbSAnLi9pbmRleC5qcyc7XG5cbi8qKlxuICogR2V0cyBBbXBsaWZ5IGJhY2tlbmQgb3V0cHV0cyBmcm9tIHN0YWNrIG1ldGFkYXRhIGFuZCBvdXRwdXRzXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGFja01ldGFkYXRhQmFja2VuZE91dHB1dFJldHJpZXZhbFN0cmF0ZWd5XG4gIGltcGxlbWVudHMgQmFja2VuZE91dHB1dFJldHJpZXZhbFN0cmF0ZWd5XG57XG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSB3aXRoIGEgQ2xvdWRGb3JtYXRpb25DbGllbnQgYW5kIGEgU3RhY2tOYW1lUmVzb2x2ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2ZuQ2xpZW50OiBDbG91ZEZvcm1hdGlvbkNsaWVudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0YWNrTmFtZVJlc29sdmVyOiBNYWluU3RhY2tOYW1lUmVzb2x2ZXJcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgc3RhY2tOYW1lLCB0aGVuIHF1ZXJpZXMgQ0ZOIGZvciB0aGUgc3RhY2sgbWV0YWRhdGEgYW5kIG91dHB1dHNcbiAgICpcbiAgICogSXQgY29tYmluZXMgdGhlIG1ldGFkYXRhIGFuZCBvdXRwdXRzIHRvIHJlY29uc3RydWN0IHRoZSBkYXRhIG9iamVjdCB0aGF0IHdhcyBwcm92aWRlZCBieSB0aGUgQW1wbGlmeSBjb25zdHJ1Y3RzIHdoZW4gd3JpdGluZyB0aGUgb3V0cHV0LlxuICAgKiBFeGNlcHQgbm93IHRoZSBkYXRhIGNvbnRhaW5zIHRoZSByZXNvbHZlZCB2YWx1ZXMgb2YgdGhlIGRlcGxveWVkIHJlc291cmNlcyByYXRoZXIgdGhhbiBDRk4gcmVmZXJlbmNlc1xuICAgKi9cbiAgZmV0Y2hCYWNrZW5kT3V0cHV0ID0gYXN5bmMgKCk6IFByb21pc2U8QmFja2VuZE91dHB1dD4gPT4ge1xuICAgIGNvbnN0IHN0YWNrTmFtZSA9IGF3YWl0IHRoaXMuc3RhY2tOYW1lUmVzb2x2ZXIucmVzb2x2ZU1haW5TdGFja05hbWUoKTtcblxuICAgIC8vIEdldFRlbXBsYXRlU3VtbWFyeSBpbmNsdWRlcyB0aGUgdGVtcGxhdGUgbWV0YWRhdGEgYXMgYSBzdHJpbmdcbiAgICBjb25zdCB0ZW1wbGF0ZVN1bW1hcnkgPSBhd2FpdCB0aGlzLmNmbkNsaWVudC5zZW5kKFxuICAgICAgbmV3IEdldFRlbXBsYXRlU3VtbWFyeUNvbW1hbmQoeyBTdGFja05hbWU6IHN0YWNrTmFtZSB9KVxuICAgICk7XG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZVN1bW1hcnkuTWV0YWRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgQmFja2VuZE91dHB1dENsaWVudEVycm9yKFxuICAgICAgICBCYWNrZW5kT3V0cHV0Q2xpZW50RXJyb3JUeXBlLk1FVEFEQVRBX1JFVFJJRVZBTF9FUlJPUixcbiAgICAgICAgJ1N0YWNrIHRlbXBsYXRlIG1ldGFkYXRhIGlzIG5vdCBhIHN0cmluZydcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YWRhdGFPYmplY3QgPSBKU09OLnBhcnNlKHRlbXBsYXRlU3VtbWFyeS5NZXRhZGF0YSk7XG5cbiAgICAvLyBwYXJzZSBhbmQgdmFsaWRhdGUgdGhlIG1ldGFkYXRhIG9iamVjdFxuICAgIGNvbnN0IGJhY2tlbmRPdXRwdXRNZXRhZGF0YSA9XG4gICAgICBiYWNrZW5kT3V0cHV0U3RhY2tNZXRhZGF0YVNjaGVtYS5wYXJzZShtZXRhZGF0YU9iamVjdCk7XG5cbiAgICAvLyBEZXNjcmliZVN0YWNrcyBpbmNsdWRlcyB0aGUgdGVtcGxhdGUgb3V0cHV0XG4gICAgY29uc3Qgc3RhY2tEZXNjcmlwdGlvbiA9IGF3YWl0IHRoaXMuY2ZuQ2xpZW50LnNlbmQoXG4gICAgICBuZXcgRGVzY3JpYmVTdGFja3NDb21tYW5kKHsgU3RhY2tOYW1lOiBzdGFja05hbWUgfSlcbiAgICApO1xuXG4gICAgY29uc3Qgb3V0cHV0cyA9IHN0YWNrRGVzY3JpcHRpb24/LlN0YWNrcz8uWzBdPy5PdXRwdXRzO1xuICAgIGlmIChvdXRwdXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChzdGFja0Rlc2NyaXB0aW9uLlN0YWNrcz8uWzBdLlN0YWNrU3RhdHVzPy5lbmRzV2l0aCgnX0lOX1BST0dSRVNTJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJhY2tlbmRPdXRwdXRDbGllbnRFcnJvcihcbiAgICAgICAgICBCYWNrZW5kT3V0cHV0Q2xpZW50RXJyb3JUeXBlLk1FVEFEQVRBX1JFVFJJRVZBTF9FUlJPUixcbiAgICAgICAgICBgJHtcbiAgICAgICAgICAgIHN0YWNrRGVzY3JpcHRpb24uU3RhY2tzPy5bMF0uU3RhY2tOYW1lID8/ICdTdGFjaydcbiAgICAgICAgICB9IGlzIGN1cnJlbnRseSBpbiAke1xuICAgICAgICAgICAgc3RhY2tEZXNjcmlwdGlvbi5TdGFja3M/LlswXS5TdGFja1N0YXR1c1xuICAgICAgICAgIH0uIE1ldGFkYXRhIHdpbGwgYmUgYXZhaWxhYmxlIGFmdGVyIHN0YWNrIGNvbXBsZXRlcyBwcm9jZXNzaW5nLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCYWNrZW5kT3V0cHV0Q2xpZW50RXJyb3IoXG4gICAgICAgIEJhY2tlbmRPdXRwdXRDbGllbnRFcnJvclR5cGUuTUVUQURBVEFfUkVUUklFVkFMX0VSUk9SLFxuICAgICAgICAnU3RhY2sgb3V0cHV0cyBhcmUgdW5kZWZpbmVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBvdXRwdXRzIGlzIGEgbGlzdCBvZiBvdXRwdXQgZW50cmllcy4gaGVyZSB3ZSB0dXJuIHRoYXQgaW50byBhIFJlY29yZDxuYW1lLCB2YWx1ZT4gb2JqZWN0XG4gICAgY29uc3Qgc3RhY2tPdXRwdXRSZWNvcmQgPSBvdXRwdXRzXG4gICAgICAuZmlsdGVyKChvdXRwdXQpID0+ICEhb3V0cHV0Lk91dHB1dFZhbHVlICYmICEhb3V0cHV0Lk91dHB1dEtleSlcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChhY2N1bXVsYXRvciwgb3V0cHV0RW50cnkpID0+ICh7XG4gICAgICAgICAgLi4uYWNjdW11bGF0b3IsXG4gICAgICAgICAgLy8gaXQncyBzYWZlIHRvIGRpc2FibGUgdGhpcyBydWxlIGJlY2F1c2Ugd2UndmUgYWxyZWFkeSBmaWx0ZXJlZCBvdXQgcG90ZW50aWFsbHkgdW5kZWZpbmVkIG91dHB1dHNcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgIFtvdXRwdXRFbnRyeS5PdXRwdXRLZXkhXTogb3V0cHV0RW50cnkuT3V0cHV0VmFsdWUhLFxuICAgICAgICB9KSxcbiAgICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgICAgKTtcblxuICAgIC8vIG5vdyB3ZSBpdGVyYXRlIG92ZXIgdGhlIG1ldGFkYXRhIGVudHJpZXMgYW5kIHJlY29uc3RydWN0IHRoZSBkYXRhIG9iamVjdCBiYXNlZCBvbiB0aGUgc3RhY2tPdXRwdXRzIHRoYXQgZWFjaCBjb25zdHJ1Y3QgcGFja2FnZSBzZXRcbiAgICBjb25zdCByZXN1bHQ6IEJhY2tlbmRPdXRwdXQgPSB7fTtcbiAgICBPYmplY3QuZW50cmllcyhiYWNrZW5kT3V0cHV0TWV0YWRhdGEpLmZvckVhY2goKFtvdXRwdXRLZXlOYW1lLCBlbnRyeV0pID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dERhdGEgPSBlbnRyeS5zdGFja091dHB1dHMucmVkdWNlKFxuICAgICAgICAoYWNjdW11bGF0b3IsIG91dHB1dE5hbWUpID0+IHtcbiAgICAgICAgICBpZiAoc3RhY2tPdXRwdXRSZWNvcmRbb3V0cHV0TmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJhY2tlbmRPdXRwdXRDbGllbnRFcnJvcihcbiAgICAgICAgICAgICAgQmFja2VuZE91dHB1dENsaWVudEVycm9yVHlwZS5NRVRBREFUQV9SRVRSSUVWQUxfRVJST1IsXG4gICAgICAgICAgICAgIGBPdXRwdXQgJHtvdXRwdXROYW1lfSBub3QgZm91bmQgaW4gc3RhY2tgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uYWNjdW11bGF0b3IsXG4gICAgICAgICAgICBbb3V0cHV0TmFtZV06IHN0YWNrT3V0cHV0UmVjb3JkW291dHB1dE5hbWVdLFxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHt9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICAgICk7XG4gICAgICByZXN1bHRbb3V0cHV0S2V5TmFtZV0gPSB7XG4gICAgICAgIHZlcnNpb246IGVudHJ5LnZlcnNpb24sXG4gICAgICAgIHBheWxvYWQ6IG91dHB1dERhdGEsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG4iXX0=