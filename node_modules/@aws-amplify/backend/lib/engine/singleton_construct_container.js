import { getBackendIdentifier } from '../backend_identifier.js';
import { DefaultBackendSecretResolver } from './backend-secret/backend_secret_resolver.js';
/**
 * Serves as a DI container and shared state store for initializing Amplify constructs
 */
export class SingletonConstructContainer {
    stackResolver;
    // uses the CacheEntryGenerator as the map key. The value is what the generator returned the first time it was seen
    constructCache = new Map();
    providerFactoryTokenMap = {};
    /**
     * Initialize the BackendBuildState with a root stack
     */
    constructor(stackResolver) {
        this.stackResolver = stackResolver;
    }
    /**
     * If generator has been seen before, the cached Construct instance is returned
     * Otherwise, the generator is called and the value is cached and returned
     */
    getOrCompute = (generator) => {
        if (!this.constructCache.has(generator)) {
            const scope = this.stackResolver.getStackFor(generator.resourceGroupName);
            const backendId = getBackendIdentifier(scope);
            const backendSecretResolver = new DefaultBackendSecretResolver(scope, backendId);
            this.constructCache.set(generator, generator.generateContainerEntry(scope, backendSecretResolver));
        }
        return this.constructCache.get(generator);
    };
    /**
     * Gets a ConstructFactory that has previously been registered to a given token.
     * Returns undefined if no construct factory is found for the specified token.
     *
     * NOTE: The return type of this function cannot be guaranteed at compile time because factories are dynamically registered at runtime
     * The return type of the factory is a contract that must be negotiated by the entity that registers a token and the entity that retrieves a token.
     *
     * By convention, tokens should be the name of type T
     */
    getConstructFactory = (token) => {
        if (token in this.providerFactoryTokenMap) {
            return this.providerFactoryTokenMap[token];
        }
        return;
    };
    /**
     * Register a ConstructFactory to a specified token. This ConstructFactory can be retrieved later using getConstructFactory
     * Throws if the token is already registered to a different factory
     */
    registerConstructFactory = (token, provider) => {
        if (token in this.providerFactoryTokenMap &&
            this.providerFactoryTokenMap[token] !== provider) {
            throw new Error(`Token ${token} is already registered to a ProviderFactory`);
        }
        this.providerFactoryTokenMap[token] = provider;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2luZ2xldG9uX2NvbnN0cnVjdF9jb250YWluZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZW5naW5lL3NpbmdsZXRvbl9jb25zdHJ1Y3RfY29udGFpbmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQU9BLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLDZDQUE2QyxDQUFDO0FBRTNGOztHQUVHO0FBQ0gsTUFBTSxPQUFPLDJCQUEyQjtJQWFUO0lBWjdCLG1IQUFtSDtJQUNsRyxjQUFjLEdBRzNCLElBQUksR0FBRyxFQUFFLENBQUM7SUFFRyx1QkFBdUIsR0FDdEMsRUFBRSxDQUFDO0lBRUw7O09BRUc7SUFDSCxZQUE2QixhQUE0QjtRQUE1QixrQkFBYSxHQUFiLGFBQWEsQ0FBZTtJQUFHLENBQUM7SUFFN0Q7OztPQUdHO0lBQ0gsWUFBWSxHQUFHLENBQUMsU0FBMkMsRUFBYSxFQUFFO1FBQ3hFLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUN2QyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsaUJBQWlCLENBQUMsQ0FBQztZQUMxRSxNQUFNLFNBQVMsR0FBRyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM5QyxNQUFNLHFCQUFxQixHQUFHLElBQUksNEJBQTRCLENBQzVELEtBQUssRUFDTCxTQUFTLENBQ1YsQ0FBQztZQUNGLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUNyQixTQUFTLEVBQ1QsU0FBUyxDQUFDLHNCQUFzQixDQUFDLEtBQUssRUFBRSxxQkFBcUIsQ0FBQyxDQUMvRCxDQUFDO1NBQ0g7UUFDRCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBYyxDQUFDO0lBQ3pELENBQUMsQ0FBQztJQUVGOzs7Ozs7OztPQVFHO0lBQ0gsbUJBQW1CLEdBQUcsQ0FBSSxLQUFhLEVBQW1DLEVBQUU7UUFDMUUsSUFBSSxLQUFLLElBQUksSUFBSSxDQUFDLHVCQUF1QixFQUFFO1lBQ3pDLE9BQU8sSUFBSSxDQUFDLHVCQUF1QixDQUFDLEtBQUssQ0FBd0IsQ0FBQztTQUNuRTtRQUNELE9BQU87SUFDVCxDQUFDLENBQUM7SUFFRjs7O09BR0c7SUFDSCx3QkFBd0IsR0FBRyxDQUN6QixLQUFhLEVBQ2IsUUFBMEIsRUFDcEIsRUFBRTtRQUNSLElBQ0UsS0FBSyxJQUFJLElBQUksQ0FBQyx1QkFBdUI7WUFDckMsSUFBSSxDQUFDLHVCQUF1QixDQUFDLEtBQUssQ0FBQyxLQUFLLFFBQVEsRUFDaEQ7WUFDQSxNQUFNLElBQUksS0FBSyxDQUNiLFNBQVMsS0FBSyw2Q0FBNkMsQ0FDNUQsQ0FBQztTQUNIO1FBQ0QsSUFBSSxDQUFDLHVCQUF1QixDQUFDLEtBQUssQ0FBQyxHQUFHLFFBQVEsQ0FBQztJQUNqRCxDQUFDLENBQUM7Q0FDSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuaW1wb3J0IHsgU3RhY2tSZXNvbHZlciB9IGZyb20gJy4vbmVzdGVkX3N0YWNrX3Jlc29sdmVyLmpzJztcbmltcG9ydCB7XG4gIENvbnN0cnVjdENvbnRhaW5lcixcbiAgQ29uc3RydWN0Q29udGFpbmVyRW50cnlHZW5lcmF0b3IsXG4gIENvbnN0cnVjdEZhY3RvcnksXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbHVnaW4tdHlwZXMnO1xuaW1wb3J0IHsgZ2V0QmFja2VuZElkZW50aWZpZXIgfSBmcm9tICcuLi9iYWNrZW5kX2lkZW50aWZpZXIuanMnO1xuaW1wb3J0IHsgRGVmYXVsdEJhY2tlbmRTZWNyZXRSZXNvbHZlciB9IGZyb20gJy4vYmFja2VuZC1zZWNyZXQvYmFja2VuZF9zZWNyZXRfcmVzb2x2ZXIuanMnO1xuXG4vKipcbiAqIFNlcnZlcyBhcyBhIERJIGNvbnRhaW5lciBhbmQgc2hhcmVkIHN0YXRlIHN0b3JlIGZvciBpbml0aWFsaXppbmcgQW1wbGlmeSBjb25zdHJ1Y3RzXG4gKi9cbmV4cG9ydCBjbGFzcyBTaW5nbGV0b25Db25zdHJ1Y3RDb250YWluZXIgaW1wbGVtZW50cyBDb25zdHJ1Y3RDb250YWluZXIge1xuICAvLyB1c2VzIHRoZSBDYWNoZUVudHJ5R2VuZXJhdG9yIGFzIHRoZSBtYXAga2V5LiBUaGUgdmFsdWUgaXMgd2hhdCB0aGUgZ2VuZXJhdG9yIHJldHVybmVkIHRoZSBmaXJzdCB0aW1lIGl0IHdhcyBzZWVuXG4gIHByaXZhdGUgcmVhZG9ubHkgY29uc3RydWN0Q2FjaGU6IE1hcDxcbiAgICBDb25zdHJ1Y3RDb250YWluZXJFbnRyeUdlbmVyYXRvcixcbiAgICBDb25zdHJ1Y3RcbiAgPiA9IG5ldyBNYXAoKTtcblxuICBwcml2YXRlIHJlYWRvbmx5IHByb3ZpZGVyRmFjdG9yeVRva2VuTWFwOiBSZWNvcmQ8c3RyaW5nLCBDb25zdHJ1Y3RGYWN0b3J5PiA9XG4gICAge307XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIEJhY2tlbmRCdWlsZFN0YXRlIHdpdGggYSByb290IHN0YWNrXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHN0YWNrUmVzb2x2ZXI6IFN0YWNrUmVzb2x2ZXIpIHt9XG5cbiAgLyoqXG4gICAqIElmIGdlbmVyYXRvciBoYXMgYmVlbiBzZWVuIGJlZm9yZSwgdGhlIGNhY2hlZCBDb25zdHJ1Y3QgaW5zdGFuY2UgaXMgcmV0dXJuZWRcbiAgICogT3RoZXJ3aXNlLCB0aGUgZ2VuZXJhdG9yIGlzIGNhbGxlZCBhbmQgdGhlIHZhbHVlIGlzIGNhY2hlZCBhbmQgcmV0dXJuZWRcbiAgICovXG4gIGdldE9yQ29tcHV0ZSA9IChnZW5lcmF0b3I6IENvbnN0cnVjdENvbnRhaW5lckVudHJ5R2VuZXJhdG9yKTogQ29uc3RydWN0ID0+IHtcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0Q2FjaGUuaGFzKGdlbmVyYXRvcikpIHtcbiAgICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zdGFja1Jlc29sdmVyLmdldFN0YWNrRm9yKGdlbmVyYXRvci5yZXNvdXJjZUdyb3VwTmFtZSk7XG4gICAgICBjb25zdCBiYWNrZW5kSWQgPSBnZXRCYWNrZW5kSWRlbnRpZmllcihzY29wZSk7XG4gICAgICBjb25zdCBiYWNrZW5kU2VjcmV0UmVzb2x2ZXIgPSBuZXcgRGVmYXVsdEJhY2tlbmRTZWNyZXRSZXNvbHZlcihcbiAgICAgICAgc2NvcGUsXG4gICAgICAgIGJhY2tlbmRJZFxuICAgICAgKTtcbiAgICAgIHRoaXMuY29uc3RydWN0Q2FjaGUuc2V0KFxuICAgICAgICBnZW5lcmF0b3IsXG4gICAgICAgIGdlbmVyYXRvci5nZW5lcmF0ZUNvbnRhaW5lckVudHJ5KHNjb3BlLCBiYWNrZW5kU2VjcmV0UmVzb2x2ZXIpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RDYWNoZS5nZXQoZ2VuZXJhdG9yKSBhcyBDb25zdHJ1Y3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYSBDb25zdHJ1Y3RGYWN0b3J5IHRoYXQgaGFzIHByZXZpb3VzbHkgYmVlbiByZWdpc3RlcmVkIHRvIGEgZ2l2ZW4gdG9rZW4uXG4gICAqIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vIGNvbnN0cnVjdCBmYWN0b3J5IGlzIGZvdW5kIGZvciB0aGUgc3BlY2lmaWVkIHRva2VuLlxuICAgKlxuICAgKiBOT1RFOiBUaGUgcmV0dXJuIHR5cGUgb2YgdGhpcyBmdW5jdGlvbiBjYW5ub3QgYmUgZ3VhcmFudGVlZCBhdCBjb21waWxlIHRpbWUgYmVjYXVzZSBmYWN0b3JpZXMgYXJlIGR5bmFtaWNhbGx5IHJlZ2lzdGVyZWQgYXQgcnVudGltZVxuICAgKiBUaGUgcmV0dXJuIHR5cGUgb2YgdGhlIGZhY3RvcnkgaXMgYSBjb250cmFjdCB0aGF0IG11c3QgYmUgbmVnb3RpYXRlZCBieSB0aGUgZW50aXR5IHRoYXQgcmVnaXN0ZXJzIGEgdG9rZW4gYW5kIHRoZSBlbnRpdHkgdGhhdCByZXRyaWV2ZXMgYSB0b2tlbi5cbiAgICpcbiAgICogQnkgY29udmVudGlvbiwgdG9rZW5zIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0eXBlIFRcbiAgICovXG4gIGdldENvbnN0cnVjdEZhY3RvcnkgPSA8VD4odG9rZW46IHN0cmluZyk6IENvbnN0cnVjdEZhY3Rvcnk8VD4gfCB1bmRlZmluZWQgPT4ge1xuICAgIGlmICh0b2tlbiBpbiB0aGlzLnByb3ZpZGVyRmFjdG9yeVRva2VuTWFwKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm92aWRlckZhY3RvcnlUb2tlbk1hcFt0b2tlbl0gYXMgQ29uc3RydWN0RmFjdG9yeTxUPjtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIENvbnN0cnVjdEZhY3RvcnkgdG8gYSBzcGVjaWZpZWQgdG9rZW4uIFRoaXMgQ29uc3RydWN0RmFjdG9yeSBjYW4gYmUgcmV0cmlldmVkIGxhdGVyIHVzaW5nIGdldENvbnN0cnVjdEZhY3RvcnlcbiAgICogVGhyb3dzIGlmIHRoZSB0b2tlbiBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgdG8gYSBkaWZmZXJlbnQgZmFjdG9yeVxuICAgKi9cbiAgcmVnaXN0ZXJDb25zdHJ1Y3RGYWN0b3J5ID0gKFxuICAgIHRva2VuOiBzdHJpbmcsXG4gICAgcHJvdmlkZXI6IENvbnN0cnVjdEZhY3RvcnlcbiAgKTogdm9pZCA9PiB7XG4gICAgaWYgKFxuICAgICAgdG9rZW4gaW4gdGhpcy5wcm92aWRlckZhY3RvcnlUb2tlbk1hcCAmJlxuICAgICAgdGhpcy5wcm92aWRlckZhY3RvcnlUb2tlbk1hcFt0b2tlbl0gIT09IHByb3ZpZGVyXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUb2tlbiAke3Rva2VufSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgdG8gYSBQcm92aWRlckZhY3RvcnlgXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnByb3ZpZGVyRmFjdG9yeVRva2VuTWFwW3Rva2VuXSA9IHByb3ZpZGVyO1xuICB9O1xufVxuIl19