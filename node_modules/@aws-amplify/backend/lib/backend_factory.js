import { NestedStackResolver, } from './engine/nested_stack_resolver.js';
import { SingletonConstructContainer } from './engine/singleton_construct_container.js';
import { ToggleableImportPathVerifier } from './engine/toggleable_import_path_verifier.js';
import { AttributionMetadataStorage, StackMetadataBackendOutputStorageStrategy, } from '@aws-amplify/backend-output-storage';
import { createDefaultStack } from './default_stack_factory.js';
import { getBackendIdentifier } from './backend_identifier.js';
import { platformOutputKey } from '@aws-amplify/backend-output-schemas';
import { fileURLToPath } from 'url';
import { AmplifyBranchLinkerConstruct } from './engine/branch-linker/branch_linker_construct.js';
// Be very careful editing this value. It is the value used in the BI metrics to attribute stacks as Amplify root stacks
const rootStackTypeIdentifier = 'root';
/**
 * Factory that collects and instantiates all the Amplify backend constructs
 */
export class BackendFactory {
    stackResolver;
    /**
     * These are the resolved CDK constructs that are created by the inputs to the constructor
     * Used for overriding properties of underlying CDK constructs or to reference in custom CDK code
     */
    resources;
    /**
     * Initialize an Amplify backend with the given construct factories and in the given CDK App.
     * If no CDK App is specified a new one is created
     */
    constructor(constructFactories, stack = createDefaultStack()) {
        new AttributionMetadataStorage().storeAttributionMetadata(stack, rootStackTypeIdentifier, fileURLToPath(new URL('../package.json', import.meta.url)));
        this.stackResolver = new NestedStackResolver(stack, new AttributionMetadataStorage());
        const constructContainer = new SingletonConstructContainer(this.stackResolver);
        const outputStorageStrategy = new StackMetadataBackendOutputStorageStrategy(stack);
        const backendId = getBackendIdentifier(stack);
        outputStorageStrategy.addBackendOutputEntry(platformOutputKey, {
            version: '1',
            payload: {
                deploymentType: backendId.type,
                region: stack.region,
            },
        });
        const shouldEnableBranchLinker = backendId.type === 'branch';
        if (shouldEnableBranchLinker) {
            new AmplifyBranchLinkerConstruct(stack, backendId);
        }
        const importPathVerifier = new ToggleableImportPathVerifier();
        // register providers but don't actually execute anything yet
        Object.values(constructFactories).forEach((factory) => {
            if (typeof factory.provides === 'string') {
                constructContainer.registerConstructFactory(factory.provides, factory);
            }
        });
        // now invoke all the factories and collect the constructs into this.resources
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.resources = {};
        Object.entries(constructFactories).forEach(([resourceName, constructFactory]) => {
            // The type inference on this.resources is not happy about this assignment because it doesn't know the exact type of .getInstance()
            // However, the assignment is okay because we are iterating over the entries of constructFactories and assigning the resource name to the corresponding instance
            this.resources[resourceName] = constructFactory.getInstance({
                constructContainer,
                outputStorageStrategy,
                importPathVerifier,
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            );
        });
    }
    /**
     * Returns a CDK stack within the Amplify project that can be used for creating custom resources.
     * If a stack has already been created with "name" then an error is thrown.
     */
    createStack = (name) => {
        return this.stackResolver.createCustomStack(name);
    };
}
/**
 * Creates a new Amplify backend instance and returns it
 * @param constructFactories - list of backend factories such as those created by `defineAuth` or `defineData`
 */
export const defineBackend = (constructFactories) => new BackendFactory(constructFactories);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZF9mYWN0b3J5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2JhY2tlbmRfZmFjdG9yeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFHQSxPQUFPLEVBQ0wsbUJBQW1CLEdBRXBCLE1BQU0sbUNBQW1DLENBQUM7QUFDM0MsT0FBTyxFQUFFLDJCQUEyQixFQUFFLE1BQU0sMkNBQTJDLENBQUM7QUFDeEYsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0sNkNBQTZDLENBQUM7QUFDM0YsT0FBTyxFQUNMLDBCQUEwQixFQUMxQix5Q0FBeUMsR0FDMUMsTUFBTSxxQ0FBcUMsQ0FBQztBQUM3QyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUNoRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUMvRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUN4RSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sS0FBSyxDQUFDO0FBRXBDLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLG1EQUFtRCxDQUFDO0FBRWpHLHdIQUF3SDtBQUN4SCxNQUFNLHVCQUF1QixHQUFHLE1BQU0sQ0FBQztBQUV2Qzs7R0FFRztBQUNILE1BQU0sT0FBTyxjQUFjO0lBSVIsYUFBYSxDQUFnQjtJQUM5Qzs7O09BR0c7SUFDTSxTQUFTLENBRWhCO0lBQ0Y7OztPQUdHO0lBQ0gsWUFBWSxrQkFBcUIsRUFBRSxRQUFlLGtCQUFrQixFQUFFO1FBQ3BFLElBQUksMEJBQTBCLEVBQUUsQ0FBQyx3QkFBd0IsQ0FDdkQsS0FBSyxFQUNMLHVCQUF1QixFQUN2QixhQUFhLENBQUMsSUFBSSxHQUFHLENBQUMsaUJBQWlCLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUMzRCxDQUFDO1FBQ0YsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLG1CQUFtQixDQUMxQyxLQUFLLEVBQ0wsSUFBSSwwQkFBMEIsRUFBRSxDQUNqQyxDQUFDO1FBRUYsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLDJCQUEyQixDQUN4RCxJQUFJLENBQUMsYUFBYSxDQUNuQixDQUFDO1FBRUYsTUFBTSxxQkFBcUIsR0FBRyxJQUFJLHlDQUF5QyxDQUN6RSxLQUFLLENBQ04sQ0FBQztRQUVGLE1BQU0sU0FBUyxHQUFHLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzlDLHFCQUFxQixDQUFDLHFCQUFxQixDQUFDLGlCQUFpQixFQUFFO1lBQzdELE9BQU8sRUFBRSxHQUFHO1lBQ1osT0FBTyxFQUFFO2dCQUNQLGNBQWMsRUFBRSxTQUFTLENBQUMsSUFBSTtnQkFDOUIsTUFBTSxFQUFFLEtBQUssQ0FBQyxNQUFNO2FBQ3JCO1NBQ0YsQ0FBQyxDQUFDO1FBRUgsTUFBTSx3QkFBd0IsR0FBRyxTQUFTLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQztRQUU3RCxJQUFJLHdCQUF3QixFQUFFO1lBQzVCLElBQUksNEJBQTRCLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1NBQ3BEO1FBRUQsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLDRCQUE0QixFQUFFLENBQUM7UUFFOUQsNkRBQTZEO1FBQzdELE1BQU0sQ0FBQyxNQUFNLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtZQUNwRCxJQUFJLE9BQU8sT0FBTyxDQUFDLFFBQVEsS0FBSyxRQUFRLEVBQUU7Z0JBQ3hDLGtCQUFrQixDQUFDLHdCQUF3QixDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFDeEU7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUVILDhFQUE4RTtRQUM5RSw4REFBOEQ7UUFDOUQsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFTLENBQUM7UUFDM0IsTUFBTSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLE9BQU8sQ0FDeEMsQ0FBQyxDQUFDLFlBQVksRUFBRSxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUU7WUFDbkMsbUlBQW1JO1lBQ25JLGdLQUFnSztZQUNoSyxJQUFJLENBQUMsU0FBUyxDQUFDLFlBQXVCLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxXQUFXLENBQ3BFO2dCQUNFLGtCQUFrQjtnQkFDbEIscUJBQXFCO2dCQUNyQixrQkFBa0I7YUFDbkI7WUFDRCw4REFBOEQ7YUFDeEQsQ0FBQztRQUNYLENBQUMsQ0FDRixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7T0FHRztJQUNILFdBQVcsR0FBRyxDQUFDLElBQVksRUFBUyxFQUFFO1FBQ3BDLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwRCxDQUFDLENBQUM7Q0FDSDtBQUVEOzs7R0FHRztBQUNILE1BQU0sQ0FBQyxNQUFNLGFBQWEsR0FBRyxDQUczQixrQkFBcUIsRUFDVCxFQUFFLENBQUMsSUFBSSxjQUFjLENBQUMsa0JBQWtCLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuaW1wb3J0IHsgQ29uc3RydWN0RmFjdG9yeSB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbHVnaW4tdHlwZXMnO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdhd3MtY2RrLWxpYic7XG5pbXBvcnQge1xuICBOZXN0ZWRTdGFja1Jlc29sdmVyLFxuICBTdGFja1Jlc29sdmVyLFxufSBmcm9tICcuL2VuZ2luZS9uZXN0ZWRfc3RhY2tfcmVzb2x2ZXIuanMnO1xuaW1wb3J0IHsgU2luZ2xldG9uQ29uc3RydWN0Q29udGFpbmVyIH0gZnJvbSAnLi9lbmdpbmUvc2luZ2xldG9uX2NvbnN0cnVjdF9jb250YWluZXIuanMnO1xuaW1wb3J0IHsgVG9nZ2xlYWJsZUltcG9ydFBhdGhWZXJpZmllciB9IGZyb20gJy4vZW5naW5lL3RvZ2dsZWFibGVfaW1wb3J0X3BhdGhfdmVyaWZpZXIuanMnO1xuaW1wb3J0IHtcbiAgQXR0cmlidXRpb25NZXRhZGF0YVN0b3JhZ2UsXG4gIFN0YWNrTWV0YWRhdGFCYWNrZW5kT3V0cHV0U3RvcmFnZVN0cmF0ZWd5LFxufSBmcm9tICdAYXdzLWFtcGxpZnkvYmFja2VuZC1vdXRwdXQtc3RvcmFnZSc7XG5pbXBvcnQgeyBjcmVhdGVEZWZhdWx0U3RhY2sgfSBmcm9tICcuL2RlZmF1bHRfc3RhY2tfZmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBnZXRCYWNrZW5kSWRlbnRpZmllciB9IGZyb20gJy4vYmFja2VuZF9pZGVudGlmaWVyLmpzJztcbmltcG9ydCB7IHBsYXRmb3JtT3V0cHV0S2V5IH0gZnJvbSAnQGF3cy1hbXBsaWZ5L2JhY2tlbmQtb3V0cHV0LXNjaGVtYXMnO1xuaW1wb3J0IHsgZmlsZVVSTFRvUGF0aCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgeyBCYWNrZW5kIH0gZnJvbSAnLi9iYWNrZW5kLmpzJztcbmltcG9ydCB7IEFtcGxpZnlCcmFuY2hMaW5rZXJDb25zdHJ1Y3QgfSBmcm9tICcuL2VuZ2luZS9icmFuY2gtbGlua2VyL2JyYW5jaF9saW5rZXJfY29uc3RydWN0LmpzJztcblxuLy8gQmUgdmVyeSBjYXJlZnVsIGVkaXRpbmcgdGhpcyB2YWx1ZS4gSXQgaXMgdGhlIHZhbHVlIHVzZWQgaW4gdGhlIEJJIG1ldHJpY3MgdG8gYXR0cmlidXRlIHN0YWNrcyBhcyBBbXBsaWZ5IHJvb3Qgc3RhY2tzXG5jb25zdCByb290U3RhY2tUeXBlSWRlbnRpZmllciA9ICdyb290JztcblxuLyoqXG4gKiBGYWN0b3J5IHRoYXQgY29sbGVjdHMgYW5kIGluc3RhbnRpYXRlcyBhbGwgdGhlIEFtcGxpZnkgYmFja2VuZCBjb25zdHJ1Y3RzXG4gKi9cbmV4cG9ydCBjbGFzcyBCYWNrZW5kRmFjdG9yeTxcbiAgVCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIENvbnN0cnVjdEZhY3Rvcnk8Q29uc3RydWN0Pj5cbj4gaW1wbGVtZW50cyBCYWNrZW5kPFQ+XG57XG4gIHByaXZhdGUgcmVhZG9ubHkgc3RhY2tSZXNvbHZlcjogU3RhY2tSZXNvbHZlcjtcbiAgLyoqXG4gICAqIFRoZXNlIGFyZSB0aGUgcmVzb2x2ZWQgQ0RLIGNvbnN0cnVjdHMgdGhhdCBhcmUgY3JlYXRlZCBieSB0aGUgaW5wdXRzIHRvIHRoZSBjb25zdHJ1Y3RvclxuICAgKiBVc2VkIGZvciBvdmVycmlkaW5nIHByb3BlcnRpZXMgb2YgdW5kZXJseWluZyBDREsgY29uc3RydWN0cyBvciB0byByZWZlcmVuY2UgaW4gY3VzdG9tIENESyBjb2RlXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZXM6IHtcbiAgICBbSyBpbiBrZXlvZiBUXTogUmV0dXJuVHlwZTxUW0tdWydnZXRJbnN0YW5jZSddPjtcbiAgfTtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYW4gQW1wbGlmeSBiYWNrZW5kIHdpdGggdGhlIGdpdmVuIGNvbnN0cnVjdCBmYWN0b3JpZXMgYW5kIGluIHRoZSBnaXZlbiBDREsgQXBwLlxuICAgKiBJZiBubyBDREsgQXBwIGlzIHNwZWNpZmllZCBhIG5ldyBvbmUgaXMgY3JlYXRlZFxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uc3RydWN0RmFjdG9yaWVzOiBULCBzdGFjazogU3RhY2sgPSBjcmVhdGVEZWZhdWx0U3RhY2soKSkge1xuICAgIG5ldyBBdHRyaWJ1dGlvbk1ldGFkYXRhU3RvcmFnZSgpLnN0b3JlQXR0cmlidXRpb25NZXRhZGF0YShcbiAgICAgIHN0YWNrLFxuICAgICAgcm9vdFN0YWNrVHlwZUlkZW50aWZpZXIsXG4gICAgICBmaWxlVVJMVG9QYXRoKG5ldyBVUkwoJy4uL3BhY2thZ2UuanNvbicsIGltcG9ydC5tZXRhLnVybCkpXG4gICAgKTtcbiAgICB0aGlzLnN0YWNrUmVzb2x2ZXIgPSBuZXcgTmVzdGVkU3RhY2tSZXNvbHZlcihcbiAgICAgIHN0YWNrLFxuICAgICAgbmV3IEF0dHJpYnV0aW9uTWV0YWRhdGFTdG9yYWdlKClcbiAgICApO1xuXG4gICAgY29uc3QgY29uc3RydWN0Q29udGFpbmVyID0gbmV3IFNpbmdsZXRvbkNvbnN0cnVjdENvbnRhaW5lcihcbiAgICAgIHRoaXMuc3RhY2tSZXNvbHZlclxuICAgICk7XG5cbiAgICBjb25zdCBvdXRwdXRTdG9yYWdlU3RyYXRlZ3kgPSBuZXcgU3RhY2tNZXRhZGF0YUJhY2tlbmRPdXRwdXRTdG9yYWdlU3RyYXRlZ3koXG4gICAgICBzdGFja1xuICAgICk7XG5cbiAgICBjb25zdCBiYWNrZW5kSWQgPSBnZXRCYWNrZW5kSWRlbnRpZmllcihzdGFjayk7XG4gICAgb3V0cHV0U3RvcmFnZVN0cmF0ZWd5LmFkZEJhY2tlbmRPdXRwdXRFbnRyeShwbGF0Zm9ybU91dHB1dEtleSwge1xuICAgICAgdmVyc2lvbjogJzEnLFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBkZXBsb3ltZW50VHlwZTogYmFja2VuZElkLnR5cGUsXG4gICAgICAgIHJlZ2lvbjogc3RhY2sucmVnaW9uLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHNob3VsZEVuYWJsZUJyYW5jaExpbmtlciA9IGJhY2tlbmRJZC50eXBlID09PSAnYnJhbmNoJztcblxuICAgIGlmIChzaG91bGRFbmFibGVCcmFuY2hMaW5rZXIpIHtcbiAgICAgIG5ldyBBbXBsaWZ5QnJhbmNoTGlua2VyQ29uc3RydWN0KHN0YWNrLCBiYWNrZW5kSWQpO1xuICAgIH1cblxuICAgIGNvbnN0IGltcG9ydFBhdGhWZXJpZmllciA9IG5ldyBUb2dnbGVhYmxlSW1wb3J0UGF0aFZlcmlmaWVyKCk7XG5cbiAgICAvLyByZWdpc3RlciBwcm92aWRlcnMgYnV0IGRvbid0IGFjdHVhbGx5IGV4ZWN1dGUgYW55dGhpbmcgeWV0XG4gICAgT2JqZWN0LnZhbHVlcyhjb25zdHJ1Y3RGYWN0b3JpZXMpLmZvckVhY2goKGZhY3RvcnkpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZmFjdG9yeS5wcm92aWRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3RydWN0Q29udGFpbmVyLnJlZ2lzdGVyQ29uc3RydWN0RmFjdG9yeShmYWN0b3J5LnByb3ZpZGVzLCBmYWN0b3J5KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIG5vdyBpbnZva2UgYWxsIHRoZSBmYWN0b3JpZXMgYW5kIGNvbGxlY3QgdGhlIGNvbnN0cnVjdHMgaW50byB0aGlzLnJlc291cmNlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgdGhpcy5yZXNvdXJjZXMgPSB7fSBhcyBhbnk7XG4gICAgT2JqZWN0LmVudHJpZXMoY29uc3RydWN0RmFjdG9yaWVzKS5mb3JFYWNoKFxuICAgICAgKFtyZXNvdXJjZU5hbWUsIGNvbnN0cnVjdEZhY3RvcnldKSA9PiB7XG4gICAgICAgIC8vIFRoZSB0eXBlIGluZmVyZW5jZSBvbiB0aGlzLnJlc291cmNlcyBpcyBub3QgaGFwcHkgYWJvdXQgdGhpcyBhc3NpZ25tZW50IGJlY2F1c2UgaXQgZG9lc24ndCBrbm93IHRoZSBleGFjdCB0eXBlIG9mIC5nZXRJbnN0YW5jZSgpXG4gICAgICAgIC8vIEhvd2V2ZXIsIHRoZSBhc3NpZ25tZW50IGlzIG9rYXkgYmVjYXVzZSB3ZSBhcmUgaXRlcmF0aW5nIG92ZXIgdGhlIGVudHJpZXMgb2YgY29uc3RydWN0RmFjdG9yaWVzIGFuZCBhc3NpZ25pbmcgdGhlIHJlc291cmNlIG5hbWUgdG8gdGhlIGNvcnJlc3BvbmRpbmcgaW5zdGFuY2VcbiAgICAgICAgdGhpcy5yZXNvdXJjZXNbcmVzb3VyY2VOYW1lIGFzIGtleW9mIFRdID0gY29uc3RydWN0RmFjdG9yeS5nZXRJbnN0YW5jZShcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RDb250YWluZXIsXG4gICAgICAgICAgICBvdXRwdXRTdG9yYWdlU3RyYXRlZ3ksXG4gICAgICAgICAgICBpbXBvcnRQYXRoVmVyaWZpZXIsXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICkgYXMgYW55O1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIENESyBzdGFjayB3aXRoaW4gdGhlIEFtcGxpZnkgcHJvamVjdCB0aGF0IGNhbiBiZSB1c2VkIGZvciBjcmVhdGluZyBjdXN0b20gcmVzb3VyY2VzLlxuICAgKiBJZiBhIHN0YWNrIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZCB3aXRoIFwibmFtZVwiIHRoZW4gYW4gZXJyb3IgaXMgdGhyb3duLlxuICAgKi9cbiAgY3JlYXRlU3RhY2sgPSAobmFtZTogc3RyaW5nKTogU3RhY2sgPT4ge1xuICAgIHJldHVybiB0aGlzLnN0YWNrUmVzb2x2ZXIuY3JlYXRlQ3VzdG9tU3RhY2sobmFtZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBBbXBsaWZ5IGJhY2tlbmQgaW5zdGFuY2UgYW5kIHJldHVybnMgaXRcbiAqIEBwYXJhbSBjb25zdHJ1Y3RGYWN0b3JpZXMgLSBsaXN0IG9mIGJhY2tlbmQgZmFjdG9yaWVzIHN1Y2ggYXMgdGhvc2UgY3JlYXRlZCBieSBgZGVmaW5lQXV0aGAgb3IgYGRlZmluZURhdGFgXG4gKi9cbmV4cG9ydCBjb25zdCBkZWZpbmVCYWNrZW5kID0gPFxuICBUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgQ29uc3RydWN0RmFjdG9yeTxDb25zdHJ1Y3Q+PlxuPihcbiAgY29uc3RydWN0RmFjdG9yaWVzOiBUXG4pOiBCYWNrZW5kPFQ+ID0+IG5ldyBCYWNrZW5kRmFjdG9yeShjb25zdHJ1Y3RGYWN0b3JpZXMpO1xuIl19