"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppSyncModelIntrospectionVisitor = void 0;
const visitor_plugin_common_1 = require("@graphql-codegen/visitor-plugin-common");
const scalars_1 = require("../scalars");
const process_connections_1 = require("../utils/process-connections");
const appsync_visitor_1 = require("./appsync-visitor");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const ajv_1 = __importDefault(require("ajv"));
;
;
class AppSyncModelIntrospectionVisitor extends appsync_visitor_1.AppSyncModelVisitor {
    constructor(schema, rawConfig, additionalConfig, defaultScalars = visitor_plugin_common_1.DEFAULT_SCALARS) {
        super(schema, rawConfig, additionalConfig, defaultScalars);
        this.introspectionVersion = 1;
        const modelIntrospectionSchemaText = fs_1.default.readFileSync(path_1.default.join(__dirname, '..', '..', 'schemas', 'introspection', this.introspectionVersion.toString(), 'ModelIntrospectionSchema.json'), 'utf8');
        const modelIntrospectionSchema = JSON.parse(modelIntrospectionSchemaText);
        this.schemaValidator = new ajv_1.default().compile(modelIntrospectionSchema);
    }
    generate() {
        const shouldUseModelNameFieldInHasManyAndBelongsTo = false;
        const shouldImputeKeyForUniDirectionalHasMany = true;
        const shouldUseFieldsInAssociatedWithInHasOne = true;
        this.processDirectives(shouldUseModelNameFieldInHasManyAndBelongsTo, shouldImputeKeyForUniDirectionalHasMany, shouldUseFieldsInAssociatedWithInHasOne);
        const modelIntrosepctionSchema = this.generateModelIntrospectionSchema();
        if (!this.schemaValidator(modelIntrosepctionSchema)) {
            throw new Error(`Data did not validate against the supplied schema. Underlying errors were ${JSON.stringify(this.schemaValidator.errors)}`);
        }
        return JSON.stringify(modelIntrosepctionSchema, null, 4);
    }
    generateModelIntrospectionSchema() {
        const result = {
            version: this.introspectionVersion,
            models: {},
            enums: {},
            nonModels: {},
        };
        const models = Object.values(this.getSelectedModels()).reduce((acc, model) => {
            return { ...acc, [model.name]: this.generateModelMetadata(model) };
        }, {});
        const nonModels = Object.values(this.getSelectedNonModels()).reduce((acc, nonModel) => {
            return { ...acc, [nonModel.name]: this.generateNonModelMetadata(nonModel) };
        }, {});
        const enums = Object.values(this.enumMap).reduce((acc, enumObj) => {
            return { ...acc, [this.getEnumName(enumObj)]: this.generateEnumMetadata(enumObj) };
        }, {});
        return { ...result, models, nonModels, enums };
    }
    getFieldAssociation(field) {
        if (field.connectionInfo) {
            const { connectionInfo } = field;
            const connectionAttribute = { connectionType: connectionInfo.kind };
            if (connectionInfo.kind === process_connections_1.CodeGenConnectionType.HAS_MANY) {
                connectionAttribute.associatedWith = connectionInfo.associatedWithFields.map(f => this.getFieldName(f));
            }
            else if (connectionInfo.kind === process_connections_1.CodeGenConnectionType.HAS_ONE) {
                connectionAttribute.associatedWith = connectionInfo.associatedWithFields.map(f => this.getFieldName(f));
                connectionAttribute.targetNames = connectionInfo.targetNames;
            }
            else {
                connectionAttribute.targetNames = connectionInfo.targetNames;
            }
            return connectionAttribute;
        }
    }
    generateModelAttributes(model) {
        return model.directives.map(d => ({
            type: d.name,
            properties: d.arguments,
        }));
    }
    generateModelMetadata(model) {
        return {
            ...this.generateNonModelMetadata(model),
            syncable: true,
            pluralName: this.pluralizeModelName(model),
            attributes: this.generateModelAttributes(model),
            primaryKeyInfo: this.generateModelPrimaryKeyInfo(model),
        };
    }
    generateNonModelMetadata(nonModel) {
        return {
            name: this.getModelName(nonModel),
            fields: nonModel.fields.reduce((acc, field) => {
                const fieldMeta = {
                    name: this.getFieldName(field),
                    isArray: field.isList,
                    type: this.getType(field.type),
                    isRequired: !field.isNullable,
                    attributes: [],
                };
                if (field.isListNullable !== undefined) {
                    fieldMeta.isArrayNullable = field.isListNullable;
                }
                if (field.isReadOnly !== undefined) {
                    fieldMeta.isReadOnly = field.isReadOnly;
                }
                const association = this.getFieldAssociation(field);
                if (association) {
                    fieldMeta.association = association;
                }
                acc[field.name] = fieldMeta;
                return acc;
            }, {}),
        };
    }
    generateEnumMetadata(enumObj) {
        return {
            name: enumObj.name,
            values: Object.values(enumObj.values),
        };
    }
    getType(gqlType) {
        if (gqlType in scalars_1.METADATA_SCALAR_MAP) {
            return scalars_1.METADATA_SCALAR_MAP[gqlType];
        }
        if (gqlType in this.enumMap) {
            return { enum: this.enumMap[gqlType].name };
        }
        if (gqlType in this.nonModelMap) {
            return { nonModel: gqlType };
        }
        if (gqlType in this.modelMap) {
            return { model: gqlType };
        }
        throw new Error(`Unknown type ${gqlType}`);
    }
    generateModelPrimaryKeyInfo(model) {
        const primaryKeyField = this.getModelPrimaryKeyField(model);
        if (primaryKeyField && primaryKeyField.primaryKeyInfo) {
            const { primaryKeyType, sortKeyFields } = primaryKeyField.primaryKeyInfo;
            return {
                isCustomPrimaryKey: primaryKeyType === appsync_visitor_1.CodeGenPrimaryKeyType.CustomId,
                primaryKeyFieldName: this.getFieldName(primaryKeyField),
                sortKeyFieldNames: sortKeyFields.map(field => this.getFieldName(field))
            };
        }
        throw new Error(`No primary key found for model ${model.name}`);
    }
}
exports.AppSyncModelIntrospectionVisitor = AppSyncModelIntrospectionVisitor;
//# sourceMappingURL=appsync-model-introspection-visitor.js.map