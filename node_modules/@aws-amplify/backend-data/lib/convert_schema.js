import { AmplifyDataDefinition, } from '@aws-amplify/data-construct';
/**
 * Determine if the input schema is a derived model schema, and perform type narrowing.
 * @param schema the schema that might be a derived model schema
 * @returns a boolean indicating whether the schema is a derived model schema, with type narrowing
 */
const isModelSchema = (schema) => {
    return (schema !== null &&
        typeof schema === 'object' &&
        typeof schema.transform === 'function');
};
/**
 * Given an input schema type, produce the relevant CDK Graphql Def interface
 * @param schema the input schema type
 * @returns the cdk graphql definition interface
 */
export const convertSchemaToCDK = (schema) => {
    const dbType = 'DYNAMODB';
    const provisionStrategy = 'AMPLIFY_TABLE';
    if (isModelSchema(schema)) {
        /**
         * This is not super obvious, but the IAmplifyDataDefinition interface requires a record of each model type to a
         * data source strategy (how it should be deployed and managed). Normally this is handled for customers by static
         * methods on AmplifyDataDefinition, but since the data-schema-types don't produce that today, we use the builder
         * to generate that argument for us (so it's consistent with a customer using normal Graphql strings), then
         * apply that value back into the final IAmplifyDataDefinition output for data-schema users.
         */
        const generatedModelDataSourceStrategies = AmplifyDataDefinition.fromString(schema.transform().schema, {
            dbType,
            provisionStrategy,
        }).dataSourceStrategies;
        return {
            ...schema.transform(),
            dataSourceStrategies: generatedModelDataSourceStrategies,
        };
    }
    return AmplifyDataDefinition.fromString(schema, {
        dbType,
        provisionStrategy,
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVydF9zY2hlbWEuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvY29udmVydF9zY2hlbWEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUNMLHFCQUFxQixHQUV0QixNQUFNLDZCQUE2QixDQUFDO0FBR3JDOzs7O0dBSUc7QUFDSCxNQUFNLGFBQWEsR0FBRyxDQUFDLE1BQWtCLEVBQWdDLEVBQUU7SUFDekUsT0FBTyxDQUNMLE1BQU0sS0FBSyxJQUFJO1FBQ2YsT0FBTyxNQUFNLEtBQUssUUFBUTtRQUMxQixPQUFPLE1BQU0sQ0FBQyxTQUFTLEtBQUssVUFBVSxDQUN2QyxDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBRUY7Ozs7R0FJRztBQUNILE1BQU0sQ0FBQyxNQUFNLGtCQUFrQixHQUFHLENBQ2hDLE1BQWtCLEVBQ00sRUFBRTtJQUMxQixNQUFNLE1BQU0sR0FBRyxVQUFVLENBQUM7SUFDMUIsTUFBTSxpQkFBaUIsR0FBRyxlQUFlLENBQUM7SUFFMUMsSUFBSSxhQUFhLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDekI7Ozs7OztXQU1HO1FBQ0gsTUFBTSxrQ0FBa0MsR0FBRyxxQkFBcUIsQ0FBQyxVQUFVLENBQ3pFLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxNQUFNLEVBQ3pCO1lBQ0UsTUFBTTtZQUNOLGlCQUFpQjtTQUNsQixDQUNGLENBQUMsb0JBQW9CLENBQUM7UUFDdkIsT0FBTztZQUNMLEdBQUcsTUFBTSxDQUFDLFNBQVMsRUFBRTtZQUNyQixvQkFBb0IsRUFBRSxrQ0FBa0M7U0FDekQsQ0FBQztLQUNIO0lBRUQsT0FBTyxxQkFBcUIsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFO1FBQzlDLE1BQU07UUFDTixpQkFBaUI7S0FDbEIsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVyaXZlZE1vZGVsU2NoZW1hIH0gZnJvbSAnQGF3cy1hbXBsaWZ5L2RhdGEtc2NoZW1hLXR5cGVzJztcbmltcG9ydCB7XG4gIEFtcGxpZnlEYXRhRGVmaW5pdGlvbixcbiAgSUFtcGxpZnlEYXRhRGVmaW5pdGlvbixcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L2RhdGEtY29uc3RydWN0JztcbmltcG9ydCB7IERhdGFTY2hlbWEgfSBmcm9tICcuL3R5cGVzLmpzJztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGlucHV0IHNjaGVtYSBpcyBhIGRlcml2ZWQgbW9kZWwgc2NoZW1hLCBhbmQgcGVyZm9ybSB0eXBlIG5hcnJvd2luZy5cbiAqIEBwYXJhbSBzY2hlbWEgdGhlIHNjaGVtYSB0aGF0IG1pZ2h0IGJlIGEgZGVyaXZlZCBtb2RlbCBzY2hlbWFcbiAqIEByZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHNjaGVtYSBpcyBhIGRlcml2ZWQgbW9kZWwgc2NoZW1hLCB3aXRoIHR5cGUgbmFycm93aW5nXG4gKi9cbmNvbnN0IGlzTW9kZWxTY2hlbWEgPSAoc2NoZW1hOiBEYXRhU2NoZW1hKTogc2NoZW1hIGlzIERlcml2ZWRNb2RlbFNjaGVtYSA9PiB7XG4gIHJldHVybiAoXG4gICAgc2NoZW1hICE9PSBudWxsICYmXG4gICAgdHlwZW9mIHNjaGVtYSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygc2NoZW1hLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJ1xuICApO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbnB1dCBzY2hlbWEgdHlwZSwgcHJvZHVjZSB0aGUgcmVsZXZhbnQgQ0RLIEdyYXBocWwgRGVmIGludGVyZmFjZVxuICogQHBhcmFtIHNjaGVtYSB0aGUgaW5wdXQgc2NoZW1hIHR5cGVcbiAqIEByZXR1cm5zIHRoZSBjZGsgZ3JhcGhxbCBkZWZpbml0aW9uIGludGVyZmFjZVxuICovXG5leHBvcnQgY29uc3QgY29udmVydFNjaGVtYVRvQ0RLID0gKFxuICBzY2hlbWE6IERhdGFTY2hlbWFcbik6IElBbXBsaWZ5RGF0YURlZmluaXRpb24gPT4ge1xuICBjb25zdCBkYlR5cGUgPSAnRFlOQU1PREInO1xuICBjb25zdCBwcm92aXNpb25TdHJhdGVneSA9ICdBTVBMSUZZX1RBQkxFJztcblxuICBpZiAoaXNNb2RlbFNjaGVtYShzY2hlbWEpKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBub3Qgc3VwZXIgb2J2aW91cywgYnV0IHRoZSBJQW1wbGlmeURhdGFEZWZpbml0aW9uIGludGVyZmFjZSByZXF1aXJlcyBhIHJlY29yZCBvZiBlYWNoIG1vZGVsIHR5cGUgdG8gYVxuICAgICAqIGRhdGEgc291cmNlIHN0cmF0ZWd5IChob3cgaXQgc2hvdWxkIGJlIGRlcGxveWVkIGFuZCBtYW5hZ2VkKS4gTm9ybWFsbHkgdGhpcyBpcyBoYW5kbGVkIGZvciBjdXN0b21lcnMgYnkgc3RhdGljXG4gICAgICogbWV0aG9kcyBvbiBBbXBsaWZ5RGF0YURlZmluaXRpb24sIGJ1dCBzaW5jZSB0aGUgZGF0YS1zY2hlbWEtdHlwZXMgZG9uJ3QgcHJvZHVjZSB0aGF0IHRvZGF5LCB3ZSB1c2UgdGhlIGJ1aWxkZXJcbiAgICAgKiB0byBnZW5lcmF0ZSB0aGF0IGFyZ3VtZW50IGZvciB1cyAoc28gaXQncyBjb25zaXN0ZW50IHdpdGggYSBjdXN0b21lciB1c2luZyBub3JtYWwgR3JhcGhxbCBzdHJpbmdzKSwgdGhlblxuICAgICAqIGFwcGx5IHRoYXQgdmFsdWUgYmFjayBpbnRvIHRoZSBmaW5hbCBJQW1wbGlmeURhdGFEZWZpbml0aW9uIG91dHB1dCBmb3IgZGF0YS1zY2hlbWEgdXNlcnMuXG4gICAgICovXG4gICAgY29uc3QgZ2VuZXJhdGVkTW9kZWxEYXRhU291cmNlU3RyYXRlZ2llcyA9IEFtcGxpZnlEYXRhRGVmaW5pdGlvbi5mcm9tU3RyaW5nKFxuICAgICAgc2NoZW1hLnRyYW5zZm9ybSgpLnNjaGVtYSxcbiAgICAgIHtcbiAgICAgICAgZGJUeXBlLFxuICAgICAgICBwcm92aXNpb25TdHJhdGVneSxcbiAgICAgIH1cbiAgICApLmRhdGFTb3VyY2VTdHJhdGVnaWVzO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zY2hlbWEudHJhbnNmb3JtKCksXG4gICAgICBkYXRhU291cmNlU3RyYXRlZ2llczogZ2VuZXJhdGVkTW9kZWxEYXRhU291cmNlU3RyYXRlZ2llcyxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIEFtcGxpZnlEYXRhRGVmaW5pdGlvbi5mcm9tU3RyaW5nKHNjaGVtYSwge1xuICAgIGRiVHlwZSxcbiAgICBwcm92aXNpb25TdHJhdGVneSxcbiAgfSk7XG59O1xuIl19