"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSqlLambdaResponseMappingTemplate = exports.generateSqlLambdaRequestTemplate = exports.SqlTransformer = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_model_transformer_1 = require("@aws-amplify/graphql-model-transformer");
const cdk = __importStar(require("aws-cdk-lib"));
const graphql_mapping_template_1 = require("graphql-mapping-template");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const SQL_DIRECTIVE_STACK = 'CustomSQLStack';
const directiveDefinition = `
  directive @sql(statement: String, reference: String) on FIELD_DEFINITION
`;
class SqlTransformer extends graphql_transformer_core_1.TransformerPluginBase {
    constructor() {
        super('amplify-sql-transformer', directiveDefinition);
        this.sqlDirectiveFields = new Map();
        this.field = (parent, definition, directive, ctx) => {
            var _a, _b;
            if (parent.name.value !== 'Query' && parent.name.value !== 'Mutation') {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`@sql directive can only be used on Query or Mutation types. Check type "${parent.name.value}" and field "${definition.name.value}".`);
            }
            const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
            if (!((_a = directive === null || directive === void 0 ? void 0 : directive.arguments) === null || _a === void 0 ? void 0 : _a.find((arg) => arg.name.value === 'statement')) &&
                !((_b = directive === null || directive === void 0 ? void 0 : directive.arguments) === null || _b === void 0 ? void 0 : _b.find((arg) => arg.name.value === 'reference'))) {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`@sql directive must have either a 'statement' or 'reference' argument. Check type "${parent.name.value}" and field "${definition.name.value}".`);
            }
            const args = directiveWrapped.getArguments({
                resolverTypeName: parent.name.value,
                resolverFieldName: definition.name.value,
            }, (0, graphql_transformer_core_1.generateGetArgumentsInput)(ctx.transformParameters));
            let resolver = this.sqlDirectiveFields.get(definition);
            if (resolver === undefined) {
                resolver = [];
                this.sqlDirectiveFields.set(definition, resolver);
            }
            resolver.push(args);
        };
        this.generateResolvers = (context) => {
            if (this.sqlDirectiveFields.size === 0) {
                return;
            }
            const stack = context.stackManager.createStack(SQL_DIRECTIVE_STACK);
            const env = context.synthParameters.amplifyEnvironmentName;
            stack.templateOptions.templateFormatVersion = '2010-09-09';
            stack.templateOptions.description = 'An auto-generated nested stack for the @sql directive.';
            new cdk.CfnCondition(stack, graphql_transformer_common_1.ResourceConstants.CONDITIONS.HasEnvironmentParameter, {
                expression: cdk.Fn.conditionNot(cdk.Fn.conditionEquals(env, graphql_transformer_common_1.ResourceConstants.NONE)),
            });
            this.sqlDirectiveFields.forEach((resolverFns) => {
                resolverFns.forEach((config) => {
                    var _a;
                    const { SQLLambdaDataSourceLogicalID: dataSourceId } = graphql_transformer_common_1.ResourceConstants.RESOURCES;
                    let dataSource = context.api.host.getDataSource(dataSourceId);
                    if (!dataSource) {
                        const generator = new graphql_model_transformer_1.RdsModelResourceGenerator();
                        generator.enableGenerator();
                        const typeName = config.resolverTypeName;
                        const fieldName = config.resolverFieldName;
                        const strategy = (_a = context.customSqlDataSourceStrategies) === null || _a === void 0 ? void 0 : _a.find((css) => css.typeName === typeName && css.fieldName === fieldName);
                        if (!strategy) {
                            throw new Error(`Could not find custom SQL strategy for ${typeName}.${fieldName}`);
                        }
                        generator.generateResources(context, strategy.dataSourceType.dbType);
                        dataSource = context.api.host.getDataSource(dataSourceId);
                    }
                    const statement = getStatement(config, context.customQueries);
                    const resolverResourceId = graphql_transformer_common_1.ResolverResourceIDs.ResolverResourceID(config.resolverTypeName, config.resolverFieldName);
                    const resolver = context.resolvers.generateQueryResolver(config.resolverTypeName, config.resolverFieldName, resolverResourceId, dataSource, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString((0, exports.generateSqlLambdaRequestTemplate)(statement, 'RAW_SQL', config.resolverFieldName), `${config.resolverTypeName}.${config.resolverFieldName}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString((0, exports.generateSqlLambdaResponseMappingTemplate)(), `${config.resolverTypeName}.${config.resolverFieldName}.res.vtl`));
                    resolver.addToSlot('postAuth', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(generateAuthExpressionForSandboxMode(context.transformParameters.sandboxModeEnabled), `${config.resolverTypeName}.${config.resolverFieldName}.{slotName}.{slotIndex}.req.vtl`));
                    resolver.setScope(context.stackManager.getScopeFor(resolverResourceId, SQL_DIRECTIVE_STACK));
                    context.resolvers.addResolver(config.resolverTypeName, config.resolverFieldName, resolver);
                });
            });
        };
    }
}
exports.SqlTransformer = SqlTransformer;
const generateAuthExpressionForSandboxMode = (enabled) => {
    let exp;
    const API_KEY = 'API Key Authorization';
    if (enabled)
        exp = (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.notEquals)((0, graphql_mapping_template_1.methodCall)((0, graphql_mapping_template_1.ref)('util.authType')), (0, graphql_mapping_template_1.str)(API_KEY)), (0, graphql_mapping_template_1.methodCall)((0, graphql_mapping_template_1.ref)('util.unauthorized')));
    else
        exp = (0, graphql_mapping_template_1.methodCall)((0, graphql_mapping_template_1.ref)('util.unauthorized'));
    return (0, graphql_mapping_template_1.printBlock)(`Sandbox Mode ${enabled ? 'Enabled' : 'Disabled'}`)((0, graphql_mapping_template_1.compoundExpression)([(0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.not)((0, graphql_mapping_template_1.ref)('ctx.stash.get("hasAuth")')), exp), (0, graphql_mapping_template_1.toJson)((0, graphql_mapping_template_1.obj)({}))]));
};
const getStatement = (config, customQueries) => {
    var _a;
    if (config.reference && !customQueries.has(config.reference)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@sql directive 'reference' argument must be a valid custom query name. Check type "${config.resolverTypeName}" and field "${config.resolverFieldName}". The custom query "${config.reference}" does not exist in "sql-statements" directory.`);
    }
    if (config.reference && config.statement) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@sql directive can have either 'statement' or 'reference' argument but not both. Check type "${config.resolverTypeName}" and field "${config.resolverFieldName}".`);
    }
    if (config.statement !== undefined && config.statement.trim().length === 0) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@sql directive 'statement' argument must not be empty. Check type "${config.resolverTypeName}" and field "${config.resolverFieldName}".`);
    }
    const statement = (_a = config.statement) !== null && _a !== void 0 ? _a : customQueries.get(config.reference);
    return statement;
};
const generateSqlLambdaRequestTemplate = (statement, operation, operationName) => {
    return (0, graphql_mapping_template_1.printBlock)('Invoke RDS Lambda data source')((0, graphql_mapping_template_1.compoundExpression)([
        (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)('lambdaInput'), (0, graphql_mapping_template_1.obj)({})),
        (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)('lambdaInput.parameters'), (0, graphql_mapping_template_1.obj)({})),
        (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)('lambdaInput.statement'), (0, graphql_mapping_template_1.str)(statement)),
        (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)('lambdaInput.operation'), (0, graphql_mapping_template_1.str)(operation)),
        (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)('lambdaInput.operationName'), (0, graphql_mapping_template_1.str)(operationName)),
        (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)('lambdaInput.parameters'), (0, graphql_mapping_template_1.methodCall)((0, graphql_mapping_template_1.ref)('util.defaultIfNull'), (0, graphql_mapping_template_1.ref)('context.arguments'), (0, graphql_mapping_template_1.obj)({}))),
        (0, graphql_mapping_template_1.obj)({
            version: (0, graphql_mapping_template_1.str)('2018-05-29'),
            operation: (0, graphql_mapping_template_1.str)('Invoke'),
            payload: (0, graphql_mapping_template_1.methodCall)((0, graphql_mapping_template_1.ref)('util.toJson'), (0, graphql_mapping_template_1.ref)('lambdaInput')),
        }),
    ]));
};
exports.generateSqlLambdaRequestTemplate = generateSqlLambdaRequestTemplate;
const generateSqlLambdaResponseMappingTemplate = () => {
    const statements = [];
    statements.push((0, graphql_mapping_template_1.ifElse)((0, graphql_mapping_template_1.ref)('ctx.error'), (0, graphql_mapping_template_1.methodCall)((0, graphql_mapping_template_1.ref)('util.error'), (0, graphql_mapping_template_1.ref)('ctx.error.message'), (0, graphql_mapping_template_1.ref)('ctx.error.type')), (0, graphql_mapping_template_1.toJson)((0, graphql_mapping_template_1.ref)('ctx.result'))));
    return (0, graphql_mapping_template_1.printBlock)('ResponseTemplate')((0, graphql_mapping_template_1.compoundExpression)(statements));
};
exports.generateSqlLambdaResponseMappingTemplate = generateSqlLambdaResponseMappingTemplate;
//# sourceMappingURL=graphql-sql-transformer.js.map