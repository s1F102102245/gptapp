"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RdsModelResourceGenerator = void 0;
const aws_cdk_lib_1 = require("aws-cdk-lib");
const aws_sns_1 = require("aws-cdk-lib/aws-sns");
const aws_sns_subscriptions_1 = require("aws-cdk-lib/aws-sns-subscriptions");
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_transformer_interfaces_1 = require("@aws-amplify/graphql-transformer-interfaces");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const resolvers_1 = require("../resolvers");
const rds_1 = require("../resolvers/rds");
const model_resource_generator_1 = require("./model-resource-generator");
class RdsModelResourceGenerator extends model_resource_generator_1.ModelResourceGenerator {
    constructor() {
        super(...arguments);
        this.generatorType = 'RdsModelResourceGenerator';
    }
    generateResources(context, dbTypeOverride) {
        var _a, _b, _c, _d, _e;
        if (this.isEnabled()) {
            const dbType = dbTypeOverride !== null && dbTypeOverride !== void 0 ? dbTypeOverride : (0, graphql_transformer_core_1.getImportedRDSType)(context.modelToDatasourceMap);
            const engine = (0, graphql_transformer_core_1.getEngineFromDBType)(dbType);
            const secretEntry = context.datasourceSecretParameterLocations.get(dbType);
            const { AmplifySQLLayerNotificationTopicAccount, AmplifySQLLayerNotificationTopicName, SQLLambdaDataSourceLogicalID, SQLLambdaIAMRoleLogicalID, SQLLambdaLogicalID, SQLPatchingLambdaIAMRoleLogicalID, SQLPatchingLambdaLogicalID, SQLPatchingSubscriptionLogicalID, SQLPatchingTopicLogicalID, SQLStackName, } = graphql_transformer_common_1.ResourceConstants.RESOURCES;
            const lambdaRoleScope = context.stackManager.getScopeFor(SQLLambdaIAMRoleLogicalID, SQLStackName);
            const lambdaScope = context.stackManager.getScopeFor(SQLLambdaLogicalID, SQLStackName);
            const layerVersionArn = resolveLayerVersion(lambdaScope, context);
            const role = (0, rds_1.createRdsLambdaRole)(context.resourceHelper.generateIAMRoleName(SQLLambdaIAMRoleLogicalID), lambdaRoleScope, secretEntry);
            const lambda = (0, rds_1.createRdsLambda)(lambdaScope, context.api, role, layerVersionArn, {
                engine: engine,
                username: (_a = secretEntry === null || secretEntry === void 0 ? void 0 : secretEntry.username) !== null && _a !== void 0 ? _a : '',
                password: (_b = secretEntry === null || secretEntry === void 0 ? void 0 : secretEntry.password) !== null && _b !== void 0 ? _b : '',
                host: (_c = secretEntry === null || secretEntry === void 0 ? void 0 : secretEntry.host) !== null && _c !== void 0 ? _c : '',
                port: (_d = secretEntry === null || secretEntry === void 0 ? void 0 : secretEntry.port) !== null && _d !== void 0 ? _d : '',
                database: (_e = secretEntry === null || secretEntry === void 0 ? void 0 : secretEntry.database) !== null && _e !== void 0 ? _e : '',
            }, context.sqlLambdaVpcConfig, context.sqlLambdaProvisionedConcurrencyConfig);
            const patchingLambdaRoleScope = context.stackManager.getScopeFor(SQLPatchingLambdaIAMRoleLogicalID, SQLStackName);
            const patchingLambdaScope = context.stackManager.getScopeFor(SQLPatchingLambdaLogicalID, SQLStackName);
            const patchingLambdaRole = (0, rds_1.createRdsPatchingLambdaRole)(context.resourceHelper.generateIAMRoleName(SQLPatchingLambdaIAMRoleLogicalID), patchingLambdaRoleScope, lambda.functionArn);
            const patchingLambda = (0, rds_1.createRdsPatchingLambda)(patchingLambdaScope, context.api, patchingLambdaRole, {
                LAMBDA_FUNCTION_ARN: lambda.functionArn,
            });
            const topicArn = aws_cdk_lib_1.Fn.join(':', [
                'arn',
                'aws',
                'sns',
                aws_cdk_lib_1.Fn.ref('AWS::Region'),
                AmplifySQLLayerNotificationTopicAccount,
                AmplifySQLLayerNotificationTopicName,
            ]);
            const patchingSubscriptionScope = context.stackManager.getScopeFor(SQLPatchingSubscriptionLogicalID, SQLStackName);
            const snsTopic = aws_sns_1.Topic.fromTopicArn(patchingSubscriptionScope, SQLPatchingTopicLogicalID, topicArn);
            const subscription = new aws_sns_subscriptions_1.LambdaSubscription(patchingLambda, {
                filterPolicy: {
                    Region: aws_sns_1.SubscriptionFilter.stringFilter({
                        allowlist: [aws_cdk_lib_1.Fn.ref('AWS::Region')],
                    }),
                },
            });
            snsTopic.addSubscription(subscription);
            const lambdaDataSourceScope = context.stackManager.getScopeFor(SQLLambdaDataSourceLogicalID, SQLStackName);
            const rdsDatasource = context.api.host.addLambdaDataSource(`${SQLLambdaDataSourceLogicalID}`, lambda, {}, lambdaDataSourceScope);
            this.models.forEach((model) => {
                context.dataSources.add(model, rdsDatasource);
                this.datasourceMap[model.name.value] = rdsDatasource;
            });
        }
        this.generateResolvers(context);
        this.setFieldMappingResolverReferences(context);
    }
    getVTLGenerator() {
        return new resolvers_1.RDSModelVTLGenerator();
    }
    setFieldMappingResolverReferences(context) {
        this.models.forEach((def) => {
            var _a;
            const modelName = (_a = def === null || def === void 0 ? void 0 : def.name) === null || _a === void 0 ? void 0 : _a.value;
            const modelFieldMap = context.resourceHelper.getModelFieldMap(modelName);
            if (!modelFieldMap.getMappedFields().length) {
                return;
            }
            const queryFields = this.getQueryFieldNames(def);
            const mutationFields = this.getMutationFieldNames(def);
            queryFields.forEach((query) => {
                modelFieldMap.addResolverReference({
                    typeName: query.typeName,
                    fieldName: query.fieldName,
                    isList: [graphql_transformer_interfaces_1.QueryFieldType.LIST, graphql_transformer_interfaces_1.QueryFieldType.SYNC].includes(query.type),
                });
            });
            mutationFields.forEach((mutation) => {
                modelFieldMap.addResolverReference({ typeName: mutation.typeName, fieldName: mutation.fieldName, isList: false });
            });
        });
    }
}
exports.RdsModelResourceGenerator = RdsModelResourceGenerator;
const resolveLayerVersion = (scope, context) => {
    let layerVersionArn;
    if (context.rdsLayerMapping) {
        (0, rds_1.setRDSLayerMappings)(scope, context.rdsLayerMapping);
        layerVersionArn = aws_cdk_lib_1.Fn.findInMap(graphql_transformer_common_1.ResourceConstants.RESOURCES.SQLLayerMappingID, aws_cdk_lib_1.Fn.ref('AWS::Region'), 'layerRegion');
    }
    else {
        const layerVersionCustomResource = (0, rds_1.createLayerVersionCustomResource)(scope);
        layerVersionArn = layerVersionCustomResource.getResponseField('Body');
    }
    return layerVersionArn;
};
//# sourceMappingURL=rds-model-resource-generator.js.map