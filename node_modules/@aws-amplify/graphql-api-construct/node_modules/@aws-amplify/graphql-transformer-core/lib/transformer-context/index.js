"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformerContext = exports.TransformerContextMetadata = exports.StackManager = exports.TransformerResolver = void 0;
const datasource_1 = require("./datasource");
const output_1 = require("./output");
const provider_registry_1 = require("./provider-registry");
const resolver_1 = require("./resolver");
const resource_helper_1 = require("./resource-helper");
const stack_manager_1 = require("./stack-manager");
const asset_manager_1 = require("./asset-manager");
var resolver_2 = require("./resolver");
Object.defineProperty(exports, "TransformerResolver", { enumerable: true, get: function () { return resolver_2.TransformerResolver; } });
var stack_manager_2 = require("./stack-manager");
Object.defineProperty(exports, "StackManager", { enumerable: true, get: function () { return stack_manager_2.StackManager; } });
class TransformerContextMetadata {
    constructor() {
        this.metadata = new Map();
    }
    get(key) {
        return this.metadata[key];
    }
    set(key, val) {
        this.metadata[key] = val;
    }
    has(key) {
        return this.metadata[key] !== undefined;
    }
}
exports.TransformerContextMetadata = TransformerContextMetadata;
class TransformerContext {
    constructor(options) {
        this.getResolverConfig = () => this.resolverConfig;
        const { assetProvider, authConfig, customQueries, customSqlDataSourceStrategies, datasourceSecretParameterLocations, inputDocument, modelToDatasourceMap, nestedStackProvider, parameterProvider, rdsLayerMapping, resolverConfig, scope, sqlLambdaProvisionedConcurrencyConfig, sqlLambdaVpcConfig, stackMapping, synthParameters, transformParameters, } = options;
        asset_manager_1.assetManager.setAssetProvider(assetProvider);
        this.authConfig = authConfig;
        this.customQueries = customQueries;
        this.customSqlDataSourceStrategies = customSqlDataSourceStrategies;
        this.dataSources = new datasource_1.TransformerDataSourceManager();
        this.datasourceSecretParameterLocations = datasourceSecretParameterLocations !== null && datasourceSecretParameterLocations !== void 0 ? datasourceSecretParameterLocations : new Map();
        this.inputDocument = inputDocument;
        this.metadata = new TransformerContextMetadata();
        this.modelToDatasourceMap = modelToDatasourceMap;
        this.output = new output_1.TransformerOutput(inputDocument);
        this.providerRegistry = new provider_registry_1.TransformerContextProviderRegistry();
        this.rdsLayerMapping = rdsLayerMapping;
        this.resolverConfig = resolverConfig;
        this.resolvers = new resolver_1.ResolverManager();
        this.resourceHelper = new resource_helper_1.TransformerResourceHelper(synthParameters);
        this.sqlLambdaProvisionedConcurrencyConfig = sqlLambdaProvisionedConcurrencyConfig;
        this.sqlLambdaVpcConfig = sqlLambdaVpcConfig;
        this.stackManager = new stack_manager_1.StackManager(scope, nestedStackProvider, parameterProvider, stackMapping);
        this.synthParameters = synthParameters;
        this.transformParameters = transformParameters;
    }
    bind(api) {
        this._api = api;
        this.resourceHelper.bind(api);
    }
    get api() {
        if (!this._api) {
            throw new Error('API is not initialized till generateResolver step');
        }
        return this._api;
    }
    isProjectUsingDataStore() {
        var _a, _b;
        return !!((_a = this.resolverConfig) === null || _a === void 0 ? void 0 : _a.project) || !!((_b = this.resolverConfig) === null || _b === void 0 ? void 0 : _b.models);
    }
}
exports.TransformerContext = TransformerContext;
//# sourceMappingURL=index.js.map