"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmplifyGraphqlDefinition = exports.DEFAULT_MODEL_DATA_SOURCE_STRATEGY = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const os = require("os");
const aws_appsync_1 = require("aws-cdk-lib/aws-appsync");
const internal_1 = require("./internal");
const data_source_config_1 = require("./internal/data-source-config");
exports.DEFAULT_MODEL_DATA_SOURCE_STRATEGY = {
    dbType: 'DYNAMODB',
    provisionStrategy: 'DEFAULT',
};
/**
 * Class exposing utilities to produce IAmplifyGraphqlDefinition objects given various inputs.
 */
class AmplifyGraphqlDefinition {
    /**
     * Produce a schema definition from a string input.
     *
     * **NOTE** The 'dataSourceStrategy' configuration option is in preview and is not recommended to use with production systems.
     *
     * @param schema the graphql input as a string
     * @param dataSourceStrategy the provisioning definition for datasources that resolve `@model`s and custom SQL statements in this schema.
     * The DynamoDB from CloudFormation will be used by default.
     * @experimental dataSourceStrategy
     * @returns a fully formed amplify graphql definition
     */
    static fromString(schema, dataSourceStrategy = exports.DEFAULT_MODEL_DATA_SOURCE_STRATEGY) {
        return {
            schema,
            functionSlots: [],
            referencedLambdaFunctions: {},
            dataSourceStrategies: (0, internal_1.constructDataSourceStrategyMap)(schema, dataSourceStrategy),
            customSqlDataSourceStrategies: (0, data_source_config_1.constructCustomSqlDataSourceStrategies)(schema, dataSourceStrategy),
        };
    }
    /**
     * Convert one or more appsync SchemaFile objects into an Amplify Graphql Schema, binding them to a DynamoDB data source.
     * @param filePaths one or more paths to the graphql files to process
     * @returns a fully formed amplify graphql definition, whose models will be resolved by DynamoDB tables created during deployment.
     */
    static fromFiles(...filePaths) {
        if (!Array.isArray(filePaths)) {
            filePaths = [filePaths];
        }
        const schema = filePaths.map((filePath) => new aws_appsync_1.SchemaFile({ filePath }).definition).join(os.EOL);
        return AmplifyGraphqlDefinition.fromString(schema, exports.DEFAULT_MODEL_DATA_SOURCE_STRATEGY);
    }
    /**
     * Convert one or more appsync SchemaFile objects into an Amplify Graphql Schema
     *
     * **NOTE** This API is in preview and is not recommended to use with production systems.
     *
     * @experimental
     * @param filePaths one or more paths to the graphql files to process
     * @param dataSourceStrategy the provisioning definition for datasources that resolve `@model`s in this schema. The DynamoDB from
     * CloudFormation will be used by default.
     * @returns a fully formed amplify graphql definition
     */
    static fromFilesAndStrategy(filePaths, dataSourceStrategy = exports.DEFAULT_MODEL_DATA_SOURCE_STRATEGY) {
        if (!Array.isArray(filePaths)) {
            filePaths = [filePaths];
        }
        const schema = filePaths.map((filePath) => new aws_appsync_1.SchemaFile({ filePath }).definition).join(os.EOL);
        return AmplifyGraphqlDefinition.fromString(schema, dataSourceStrategy);
    }
    /**
     * Combines multiple IAmplifyGraphqlDefinitions into a single definition.
     *
     * **NOTE** This API is in preview and is not recommended to use with production systems.
     *
     * @experimental
     * @param definitions the definitions to combine
     */
    static combine(definitions) {
        if (definitions.length === 0) {
            throw new Error('The definitions of amplify GraphQL cannot be empty.');
        }
        if (definitions.length === 1) {
            return definitions[0];
        }
        return {
            schema: definitions.map((def) => def.schema).join(os.EOL),
            functionSlots: [],
            referencedLambdaFunctions: definitions.reduce((acc, cur) => ({ ...acc, ...cur.referencedLambdaFunctions }), {}),
            dataSourceStrategies: definitions.reduce((acc, cur) => ({ ...acc, ...cur.dataSourceStrategies }), {}),
        };
    }
}
exports.AmplifyGraphqlDefinition = AmplifyGraphqlDefinition;
_a = JSII_RTTI_SYMBOL_1;
AmplifyGraphqlDefinition[_a] = { fqn: "@aws-amplify/graphql-api-construct.AmplifyGraphqlDefinition", version: "1.4.3" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW1wbGlmeS1ncmFwaHFsLWRlZmluaXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvYW1wbGlmeS1ncmFwaHFsLWRlZmluaXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSx5QkFBeUI7QUFDekIseURBQXFEO0FBRXJELHlDQUE0RDtBQUU1RCxzRUFBdUY7QUFFMUUsUUFBQSxrQ0FBa0MsR0FBNEI7SUFDekUsTUFBTSxFQUFFLFVBQVU7SUFDbEIsaUJBQWlCLEVBQUUsU0FBUztDQUM3QixDQUFDO0FBRUY7O0dBRUc7QUFDSCxNQUFhLHdCQUF3QjtJQUNuQzs7Ozs7Ozs7OztPQVVHO0lBQ0gsTUFBTSxDQUFDLFVBQVUsQ0FDZixNQUFjLEVBQ2QscUJBQThDLDBDQUFrQztRQUVoRixPQUFPO1lBQ0wsTUFBTTtZQUNOLGFBQWEsRUFBRSxFQUFFO1lBQ2pCLHlCQUF5QixFQUFFLEVBQUU7WUFDN0Isb0JBQW9CLEVBQUUsSUFBQSx5Q0FBOEIsRUFBQyxNQUFNLEVBQUUsa0JBQWtCLENBQUM7WUFDaEYsNkJBQTZCLEVBQUUsSUFBQSwyREFBc0MsRUFBQyxNQUFNLEVBQUUsa0JBQWtCLENBQUM7U0FDbEcsQ0FBQztJQUNKLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLFNBQVMsQ0FBQyxHQUFHLFNBQW1CO1FBQ3JDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQzdCLFNBQVMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQ3pCO1FBQ0QsTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsSUFBSSx3QkFBVSxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2pHLE9BQU8sd0JBQXdCLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSwwQ0FBa0MsQ0FBQyxDQUFDO0lBQ3pGLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0gsTUFBTSxDQUFDLG9CQUFvQixDQUN6QixTQUE0QixFQUM1QixxQkFBOEMsMENBQWtDO1FBRWhGLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQzdCLFNBQVMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQ3pCO1FBQ0QsTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsSUFBSSx3QkFBVSxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2pHLE9BQU8sd0JBQXdCLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUF3QztRQUNyRCxJQUFJLFdBQVcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQzVCLE1BQU0sSUFBSSxLQUFLLENBQUMscURBQXFELENBQUMsQ0FBQztTQUN4RTtRQUNELElBQUksV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDNUIsT0FBTyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdkI7UUFDRCxPQUFPO1lBQ0wsTUFBTSxFQUFFLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQztZQUN6RCxhQUFhLEVBQUUsRUFBRTtZQUNqQix5QkFBeUIsRUFBRSxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFDLHlCQUF5QixFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDL0csb0JBQW9CLEVBQUUsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsQ0FBQyxvQkFBb0IsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1NBQ3RHLENBQUM7SUFDSixDQUFDOztBQWpGSCw0REFrRkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XG5pbXBvcnQgeyBTY2hlbWFGaWxlIH0gZnJvbSAnYXdzLWNkay1saWIvYXdzLWFwcHN5bmMnO1xuaW1wb3J0IHsgSUFtcGxpZnlHcmFwaHFsRGVmaW5pdGlvbiB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgY29uc3RydWN0RGF0YVNvdXJjZVN0cmF0ZWd5TWFwIH0gZnJvbSAnLi9pbnRlcm5hbCc7XG5pbXBvcnQgeyBNb2RlbERhdGFTb3VyY2VTdHJhdGVneSB9IGZyb20gJy4vbW9kZWwtZGF0YXNvdXJjZS1zdHJhdGVneSc7XG5pbXBvcnQgeyBjb25zdHJ1Y3RDdXN0b21TcWxEYXRhU291cmNlU3RyYXRlZ2llcyB9IGZyb20gJy4vaW50ZXJuYWwvZGF0YS1zb3VyY2UtY29uZmlnJztcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfTU9ERUxfREFUQV9TT1VSQ0VfU1RSQVRFR1k6IE1vZGVsRGF0YVNvdXJjZVN0cmF0ZWd5ID0ge1xuICBkYlR5cGU6ICdEWU5BTU9EQicsXG4gIHByb3Zpc2lvblN0cmF0ZWd5OiAnREVGQVVMVCcsXG59O1xuXG4vKipcbiAqIENsYXNzIGV4cG9zaW5nIHV0aWxpdGllcyB0byBwcm9kdWNlIElBbXBsaWZ5R3JhcGhxbERlZmluaXRpb24gb2JqZWN0cyBnaXZlbiB2YXJpb3VzIGlucHV0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFtcGxpZnlHcmFwaHFsRGVmaW5pdGlvbiB7XG4gIC8qKlxuICAgKiBQcm9kdWNlIGEgc2NoZW1hIGRlZmluaXRpb24gZnJvbSBhIHN0cmluZyBpbnB1dC5cbiAgICpcbiAgICogKipOT1RFKiogVGhlICdkYXRhU291cmNlU3RyYXRlZ3knIGNvbmZpZ3VyYXRpb24gb3B0aW9uIGlzIGluIHByZXZpZXcgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCB0byB1c2Ugd2l0aCBwcm9kdWN0aW9uIHN5c3RlbXMuXG4gICAqXG4gICAqIEBwYXJhbSBzY2hlbWEgdGhlIGdyYXBocWwgaW5wdXQgYXMgYSBzdHJpbmdcbiAgICogQHBhcmFtIGRhdGFTb3VyY2VTdHJhdGVneSB0aGUgcHJvdmlzaW9uaW5nIGRlZmluaXRpb24gZm9yIGRhdGFzb3VyY2VzIHRoYXQgcmVzb2x2ZSBgQG1vZGVsYHMgYW5kIGN1c3RvbSBTUUwgc3RhdGVtZW50cyBpbiB0aGlzIHNjaGVtYS5cbiAgICogVGhlIER5bmFtb0RCIGZyb20gQ2xvdWRGb3JtYXRpb24gd2lsbCBiZSB1c2VkIGJ5IGRlZmF1bHQuXG4gICAqIEBleHBlcmltZW50YWwgZGF0YVNvdXJjZVN0cmF0ZWd5XG4gICAqIEByZXR1cm5zIGEgZnVsbHkgZm9ybWVkIGFtcGxpZnkgZ3JhcGhxbCBkZWZpbml0aW9uXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZyhcbiAgICBzY2hlbWE6IHN0cmluZyxcbiAgICBkYXRhU291cmNlU3RyYXRlZ3k6IE1vZGVsRGF0YVNvdXJjZVN0cmF0ZWd5ID0gREVGQVVMVF9NT0RFTF9EQVRBX1NPVVJDRV9TVFJBVEVHWSxcbiAgKTogSUFtcGxpZnlHcmFwaHFsRGVmaW5pdGlvbiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtYSxcbiAgICAgIGZ1bmN0aW9uU2xvdHM6IFtdLFxuICAgICAgcmVmZXJlbmNlZExhbWJkYUZ1bmN0aW9uczoge30sXG4gICAgICBkYXRhU291cmNlU3RyYXRlZ2llczogY29uc3RydWN0RGF0YVNvdXJjZVN0cmF0ZWd5TWFwKHNjaGVtYSwgZGF0YVNvdXJjZVN0cmF0ZWd5KSxcbiAgICAgIGN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVnaWVzOiBjb25zdHJ1Y3RDdXN0b21TcWxEYXRhU291cmNlU3RyYXRlZ2llcyhzY2hlbWEsIGRhdGFTb3VyY2VTdHJhdGVneSksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IG9uZSBvciBtb3JlIGFwcHN5bmMgU2NoZW1hRmlsZSBvYmplY3RzIGludG8gYW4gQW1wbGlmeSBHcmFwaHFsIFNjaGVtYSwgYmluZGluZyB0aGVtIHRvIGEgRHluYW1vREIgZGF0YSBzb3VyY2UuXG4gICAqIEBwYXJhbSBmaWxlUGF0aHMgb25lIG9yIG1vcmUgcGF0aHMgdG8gdGhlIGdyYXBocWwgZmlsZXMgdG8gcHJvY2Vzc1xuICAgKiBAcmV0dXJucyBhIGZ1bGx5IGZvcm1lZCBhbXBsaWZ5IGdyYXBocWwgZGVmaW5pdGlvbiwgd2hvc2UgbW9kZWxzIHdpbGwgYmUgcmVzb2x2ZWQgYnkgRHluYW1vREIgdGFibGVzIGNyZWF0ZWQgZHVyaW5nIGRlcGxveW1lbnQuXG4gICAqL1xuICBzdGF0aWMgZnJvbUZpbGVzKC4uLmZpbGVQYXRoczogc3RyaW5nW10pOiBJQW1wbGlmeUdyYXBocWxEZWZpbml0aW9uIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsZVBhdGhzKSkge1xuICAgICAgZmlsZVBhdGhzID0gW2ZpbGVQYXRoc107XG4gICAgfVxuICAgIGNvbnN0IHNjaGVtYSA9IGZpbGVQYXRocy5tYXAoKGZpbGVQYXRoKSA9PiBuZXcgU2NoZW1hRmlsZSh7IGZpbGVQYXRoIH0pLmRlZmluaXRpb24pLmpvaW4ob3MuRU9MKTtcbiAgICByZXR1cm4gQW1wbGlmeUdyYXBocWxEZWZpbml0aW9uLmZyb21TdHJpbmcoc2NoZW1hLCBERUZBVUxUX01PREVMX0RBVEFfU09VUkNFX1NUUkFURUdZKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IG9uZSBvciBtb3JlIGFwcHN5bmMgU2NoZW1hRmlsZSBvYmplY3RzIGludG8gYW4gQW1wbGlmeSBHcmFwaHFsIFNjaGVtYVxuICAgKlxuICAgKiAqKk5PVEUqKiBUaGlzIEFQSSBpcyBpbiBwcmV2aWV3IGFuZCBpcyBub3QgcmVjb21tZW5kZWQgdG8gdXNlIHdpdGggcHJvZHVjdGlvbiBzeXN0ZW1zLlxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqIEBwYXJhbSBmaWxlUGF0aHMgb25lIG9yIG1vcmUgcGF0aHMgdG8gdGhlIGdyYXBocWwgZmlsZXMgdG8gcHJvY2Vzc1xuICAgKiBAcGFyYW0gZGF0YVNvdXJjZVN0cmF0ZWd5IHRoZSBwcm92aXNpb25pbmcgZGVmaW5pdGlvbiBmb3IgZGF0YXNvdXJjZXMgdGhhdCByZXNvbHZlIGBAbW9kZWxgcyBpbiB0aGlzIHNjaGVtYS4gVGhlIER5bmFtb0RCIGZyb21cbiAgICogQ2xvdWRGb3JtYXRpb24gd2lsbCBiZSB1c2VkIGJ5IGRlZmF1bHQuXG4gICAqIEByZXR1cm5zIGEgZnVsbHkgZm9ybWVkIGFtcGxpZnkgZ3JhcGhxbCBkZWZpbml0aW9uXG4gICAqL1xuICBzdGF0aWMgZnJvbUZpbGVzQW5kU3RyYXRlZ3koXG4gICAgZmlsZVBhdGhzOiBzdHJpbmcgfCBzdHJpbmdbXSxcbiAgICBkYXRhU291cmNlU3RyYXRlZ3k6IE1vZGVsRGF0YVNvdXJjZVN0cmF0ZWd5ID0gREVGQVVMVF9NT0RFTF9EQVRBX1NPVVJDRV9TVFJBVEVHWSxcbiAgKTogSUFtcGxpZnlHcmFwaHFsRGVmaW5pdGlvbiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZpbGVQYXRocykpIHtcbiAgICAgIGZpbGVQYXRocyA9IFtmaWxlUGF0aHNdO1xuICAgIH1cbiAgICBjb25zdCBzY2hlbWEgPSBmaWxlUGF0aHMubWFwKChmaWxlUGF0aCkgPT4gbmV3IFNjaGVtYUZpbGUoeyBmaWxlUGF0aCB9KS5kZWZpbml0aW9uKS5qb2luKG9zLkVPTCk7XG4gICAgcmV0dXJuIEFtcGxpZnlHcmFwaHFsRGVmaW5pdGlvbi5mcm9tU3RyaW5nKHNjaGVtYSwgZGF0YVNvdXJjZVN0cmF0ZWd5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lcyBtdWx0aXBsZSBJQW1wbGlmeUdyYXBocWxEZWZpbml0aW9ucyBpbnRvIGEgc2luZ2xlIGRlZmluaXRpb24uXG4gICAqXG4gICAqICoqTk9URSoqIFRoaXMgQVBJIGlzIGluIHByZXZpZXcgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCB0byB1c2Ugd2l0aCBwcm9kdWN0aW9uIHN5c3RlbXMuXG4gICAqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICogQHBhcmFtIGRlZmluaXRpb25zIHRoZSBkZWZpbml0aW9ucyB0byBjb21iaW5lXG4gICAqL1xuICBzdGF0aWMgY29tYmluZShkZWZpbml0aW9uczogSUFtcGxpZnlHcmFwaHFsRGVmaW5pdGlvbltdKTogSUFtcGxpZnlHcmFwaHFsRGVmaW5pdGlvbiB7XG4gICAgaWYgKGRlZmluaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGVmaW5pdGlvbnMgb2YgYW1wbGlmeSBHcmFwaFFMIGNhbm5vdCBiZSBlbXB0eS4nKTtcbiAgICB9XG4gICAgaWYgKGRlZmluaXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGRlZmluaXRpb25zWzBdO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2NoZW1hOiBkZWZpbml0aW9ucy5tYXAoKGRlZikgPT4gZGVmLnNjaGVtYSkuam9pbihvcy5FT0wpLFxuICAgICAgZnVuY3Rpb25TbG90czogW10sXG4gICAgICByZWZlcmVuY2VkTGFtYmRhRnVuY3Rpb25zOiBkZWZpbml0aW9ucy5yZWR1Y2UoKGFjYywgY3VyKSA9PiAoeyAuLi5hY2MsIC4uLmN1ci5yZWZlcmVuY2VkTGFtYmRhRnVuY3Rpb25zIH0pLCB7fSksXG4gICAgICBkYXRhU291cmNlU3RyYXRlZ2llczogZGVmaW5pdGlvbnMucmVkdWNlKChhY2MsIGN1cikgPT4gKHsgLi4uYWNjLCAuLi5jdXIuZGF0YVNvdXJjZVN0cmF0ZWdpZXMgfSksIHt9KSxcbiAgICB9O1xuICB9XG59XG4iXX0=