"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapInterfaceCustomSqlStrategiesToImplementationStrategies = exports.constructCustomSqlDataSourceStrategies = exports.parseDataSourceConfig = void 0;
const graphql_1 = require("graphql");
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const utils_1 = require("@aws-amplify/graphql-transformer-core/lib/utils");
/**
 * An internal helper to convert from a map of model-to-ModelDataSourceStrategies to the map of model-to-DataSourceTypes that internal
 * transform processing requires. TODO: We can remove this once we refactor the internals to use ModelDataSourceStrategies natively.
 */
const parseDataSourceConfig = (dataSourceDefinitionMap) => {
    const modelToDatasourceMap = new Map();
    for (const [key, value] of Object.entries(dataSourceDefinitionMap)) {
        const dataSourceType = (0, graphql_transformer_core_1.dataSourceStrategyToDataSourceType)(value);
        modelToDatasourceMap.set(key, dataSourceType);
    }
    return {
        modelToDatasourceMap,
    };
};
exports.parseDataSourceConfig = parseDataSourceConfig;
/**
 * Creates an interface flavor of customSqlDataSourceStrategies from a factory method's schema and data source. Internally, this function
 * scans the fields of `Query` and `Mutation` looking for fields annotated with the `@sql` directive and designates the specified
 * dataSourceStrategy to fulfill those custom queries.
 *
 * Note that we do not scan for `Subscription` fields: `@sql` directives are not allowed on those, and it wouldn't make sense to do so
 * anyway, since subscriptions are processed from an incoming Mutation, not as the result of a direct datasource access.
 *
 * TODO: Reword this when we refactor to use Strategies throughout the implementation rather than DataSources.
 */
const constructCustomSqlDataSourceStrategies = (schema, dataSourceStrategy) => {
    if (!(0, graphql_transformer_core_1.isSqlStrategy)(dataSourceStrategy)) {
        return [];
    }
    const parsedSchema = (0, graphql_1.parse)(schema);
    const queryNode = parsedSchema.definitions.find(graphql_transformer_core_1.isQueryNode);
    const mutationNode = parsedSchema.definitions.find(graphql_transformer_core_1.isMutationNode);
    if (!queryNode && !mutationNode) {
        return [];
    }
    const customSqlDataSourceStrategies = [];
    if (queryNode) {
        const fields = (0, graphql_transformer_core_1.fieldsWithSqlDirective)(queryNode);
        for (const field of fields) {
            customSqlDataSourceStrategies.push({
                typeName: 'Query',
                fieldName: field.name.value,
                strategy: dataSourceStrategy,
            });
        }
    }
    if (mutationNode) {
        const fields = (0, graphql_transformer_core_1.fieldsWithSqlDirective)(mutationNode);
        for (const field of fields) {
            customSqlDataSourceStrategies.push({
                typeName: 'Mutation',
                fieldName: field.name.value,
                strategy: dataSourceStrategy,
            });
        }
    }
    return customSqlDataSourceStrategies;
};
exports.constructCustomSqlDataSourceStrategies = constructCustomSqlDataSourceStrategies;
/**
 * We currently use a different type structure to model strategies in the interface than we do in the implementation. This maps the
 * interface CustomSqlDataSourceStrategy (which uses SQLLambdaModelDataSourceStrategy) to the implementation flavor (which uses
 * DataSourceType).
 *
 * TODO: Remove this once we refactor the internals to use strategies rather than DataSourceTypes
 */
const mapInterfaceCustomSqlStrategiesToImplementationStrategies = (strategies) => {
    if (!strategies) {
        return [];
    }
    return strategies.map((interfaceStrategy) => ({
        fieldName: interfaceStrategy.fieldName,
        typeName: interfaceStrategy.typeName,
        dataSourceType: {
            dbType: (0, utils_1.normalizeDbType)(interfaceStrategy.strategy.dbType),
            provisionDB: false,
            provisionStrategy: "DEFAULT" /* SQLLambdaModelProvisionStrategy.DEFAULT */,
        },
    }));
};
exports.mapInterfaceCustomSqlStrategiesToImplementationStrategies = mapInterfaceCustomSqlStrategiesToImplementationStrategies;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1zb3VyY2UtY29uZmlnLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ludGVybmFsL2RhdGEtc291cmNlLWNvbmZpZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxxQ0FBZ0M7QUFNaEMsb0ZBTStDO0FBQy9DLDJFQUFrRjtBQU9sRjs7O0dBR0c7QUFDSSxNQUFNLHFCQUFxQixHQUFHLENBQUMsdUJBQWdFLEVBQW9CLEVBQUU7SUFDMUgsTUFBTSxvQkFBb0IsR0FBRyxJQUFJLEdBQUcsRUFBMEIsQ0FBQztJQUMvRCxLQUFLLE1BQU0sQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFO1FBQ2xFLE1BQU0sY0FBYyxHQUFHLElBQUEsNkRBQWtDLEVBQUMsS0FBSyxDQUFDLENBQUM7UUFDakUsb0JBQW9CLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxjQUFjLENBQUMsQ0FBQztLQUMvQztJQUNELE9BQU87UUFDTCxvQkFBb0I7S0FDckIsQ0FBQztBQUNKLENBQUMsQ0FBQztBQVRXLFFBQUEscUJBQXFCLHlCQVNoQztBQUVGOzs7Ozs7Ozs7R0FTRztBQUNJLE1BQU0sc0NBQXNDLEdBQUcsQ0FDcEQsTUFBYyxFQUNkLGtCQUEyQyxFQUNILEVBQUU7SUFDMUMsSUFBSSxDQUFDLElBQUEsd0NBQWEsRUFBQyxrQkFBa0IsQ0FBQyxFQUFFO1FBQ3RDLE9BQU8sRUFBRSxDQUFDO0tBQ1g7SUFFRCxNQUFNLFlBQVksR0FBRyxJQUFBLGVBQUssRUFBQyxNQUFNLENBQUMsQ0FBQztJQUVuQyxNQUFNLFNBQVMsR0FBRyxZQUFZLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxzQ0FBVyxDQUFDLENBQUM7SUFDN0QsTUFBTSxZQUFZLEdBQUcsWUFBWSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMseUNBQWMsQ0FBQyxDQUFDO0lBQ25FLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxZQUFZLEVBQUU7UUFDL0IsT0FBTyxFQUFFLENBQUM7S0FDWDtJQUVELE1BQU0sNkJBQTZCLEdBQTJDLEVBQUUsQ0FBQztJQUVqRixJQUFJLFNBQVMsRUFBRTtRQUNiLE1BQU0sTUFBTSxHQUFHLElBQUEsaURBQXNCLEVBQUMsU0FBUyxDQUFDLENBQUM7UUFDakQsS0FBSyxNQUFNLEtBQUssSUFBSSxNQUFNLEVBQUU7WUFDMUIsNkJBQTZCLENBQUMsSUFBSSxDQUFDO2dCQUNqQyxRQUFRLEVBQUUsT0FBTztnQkFDakIsU0FBUyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSztnQkFDM0IsUUFBUSxFQUFFLGtCQUFrQjthQUM3QixDQUFDLENBQUM7U0FDSjtLQUNGO0lBRUQsSUFBSSxZQUFZLEVBQUU7UUFDaEIsTUFBTSxNQUFNLEdBQUcsSUFBQSxpREFBc0IsRUFBQyxZQUFZLENBQUMsQ0FBQztRQUNwRCxLQUFLLE1BQU0sS0FBSyxJQUFJLE1BQU0sRUFBRTtZQUMxQiw2QkFBNkIsQ0FBQyxJQUFJLENBQUM7Z0JBQ2pDLFFBQVEsRUFBRSxVQUFVO2dCQUNwQixTQUFTLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLO2dCQUMzQixRQUFRLEVBQUUsa0JBQWtCO2FBQzdCLENBQUMsQ0FBQztTQUNKO0tBQ0Y7SUFFRCxPQUFPLDZCQUE2QixDQUFDO0FBQ3ZDLENBQUMsQ0FBQztBQXpDVyxRQUFBLHNDQUFzQywwQ0F5Q2pEO0FBRUY7Ozs7OztHQU1HO0FBQ0ksTUFBTSx5REFBeUQsR0FBRyxDQUN2RSxVQUFtRCxFQUNOLEVBQUU7SUFDL0MsSUFBSSxDQUFDLFVBQVUsRUFBRTtRQUNmLE9BQU8sRUFBRSxDQUFDO0tBQ1g7SUFDRCxPQUFPLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUM1QyxTQUFTLEVBQUUsaUJBQWlCLENBQUMsU0FBUztRQUN0QyxRQUFRLEVBQUUsaUJBQWlCLENBQUMsUUFBUTtRQUNwQyxjQUFjLEVBQUU7WUFDZCxNQUFNLEVBQUUsSUFBQSx1QkFBZSxFQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUM7WUFDMUQsV0FBVyxFQUFFLEtBQUs7WUFDbEIsaUJBQWlCLHlEQUF5QztTQUMzRDtLQUNGLENBQUMsQ0FBQyxDQUFDO0FBQ04sQ0FBQyxDQUFDO0FBZlcsUUFBQSx5REFBeUQsNkRBZXBFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2UgfSBmcm9tICdncmFwaHFsJztcbmltcG9ydCB7XG4gIEN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVneSBhcyBJbXBsZW1lbnRhdGlvbkN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVneSxcbiAgRGF0YVNvdXJjZVR5cGUsXG4gIFNRTExhbWJkYU1vZGVsUHJvdmlzaW9uU3RyYXRlZ3ksXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9ncmFwaHFsLXRyYW5zZm9ybWVyLWludGVyZmFjZXMnO1xuaW1wb3J0IHtcbiAgZGF0YVNvdXJjZVN0cmF0ZWd5VG9EYXRhU291cmNlVHlwZSxcbiAgaXNTcWxTdHJhdGVneSxcbiAgaXNRdWVyeU5vZGUsXG4gIGlzTXV0YXRpb25Ob2RlLFxuICBmaWVsZHNXaXRoU3FsRGlyZWN0aXZlLFxufSBmcm9tICdAYXdzLWFtcGxpZnkvZ3JhcGhxbC10cmFuc2Zvcm1lci1jb3JlJztcbmltcG9ydCB7IG5vcm1hbGl6ZURiVHlwZSB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9ncmFwaHFsLXRyYW5zZm9ybWVyLWNvcmUvbGliL3V0aWxzJztcbmltcG9ydCB7IEN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVneSBhcyBJbnRlcmZhY2VDdXN0b21TcWxEYXRhU291cmNlU3RyYXRlZ3ksIE1vZGVsRGF0YVNvdXJjZVN0cmF0ZWd5IH0gZnJvbSAnLi4vbW9kZWwtZGF0YXNvdXJjZS1zdHJhdGVneSc7XG5cbnR5cGUgRGF0YVNvdXJjZUNvbmZpZyA9IHtcbiAgbW9kZWxUb0RhdGFzb3VyY2VNYXA6IE1hcDxzdHJpbmcsIERhdGFTb3VyY2VUeXBlPjtcbn07XG5cbi8qKlxuICogQW4gaW50ZXJuYWwgaGVscGVyIHRvIGNvbnZlcnQgZnJvbSBhIG1hcCBvZiBtb2RlbC10by1Nb2RlbERhdGFTb3VyY2VTdHJhdGVnaWVzIHRvIHRoZSBtYXAgb2YgbW9kZWwtdG8tRGF0YVNvdXJjZVR5cGVzIHRoYXQgaW50ZXJuYWxcbiAqIHRyYW5zZm9ybSBwcm9jZXNzaW5nIHJlcXVpcmVzLiBUT0RPOiBXZSBjYW4gcmVtb3ZlIHRoaXMgb25jZSB3ZSByZWZhY3RvciB0aGUgaW50ZXJuYWxzIHRvIHVzZSBNb2RlbERhdGFTb3VyY2VTdHJhdGVnaWVzIG5hdGl2ZWx5LlxuICovXG5leHBvcnQgY29uc3QgcGFyc2VEYXRhU291cmNlQ29uZmlnID0gKGRhdGFTb3VyY2VEZWZpbml0aW9uTWFwOiBSZWNvcmQ8c3RyaW5nLCBNb2RlbERhdGFTb3VyY2VTdHJhdGVneT4pOiBEYXRhU291cmNlQ29uZmlnID0+IHtcbiAgY29uc3QgbW9kZWxUb0RhdGFzb3VyY2VNYXAgPSBuZXcgTWFwPHN0cmluZywgRGF0YVNvdXJjZVR5cGU+KCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRhdGFTb3VyY2VEZWZpbml0aW9uTWFwKSkge1xuICAgIGNvbnN0IGRhdGFTb3VyY2VUeXBlID0gZGF0YVNvdXJjZVN0cmF0ZWd5VG9EYXRhU291cmNlVHlwZSh2YWx1ZSk7XG4gICAgbW9kZWxUb0RhdGFzb3VyY2VNYXAuc2V0KGtleSwgZGF0YVNvdXJjZVR5cGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbW9kZWxUb0RhdGFzb3VyY2VNYXAsXG4gIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gaW50ZXJmYWNlIGZsYXZvciBvZiBjdXN0b21TcWxEYXRhU291cmNlU3RyYXRlZ2llcyBmcm9tIGEgZmFjdG9yeSBtZXRob2QncyBzY2hlbWEgYW5kIGRhdGEgc291cmNlLiBJbnRlcm5hbGx5LCB0aGlzIGZ1bmN0aW9uXG4gKiBzY2FucyB0aGUgZmllbGRzIG9mIGBRdWVyeWAgYW5kIGBNdXRhdGlvbmAgbG9va2luZyBmb3IgZmllbGRzIGFubm90YXRlZCB3aXRoIHRoZSBgQHNxbGAgZGlyZWN0aXZlIGFuZCBkZXNpZ25hdGVzIHRoZSBzcGVjaWZpZWRcbiAqIGRhdGFTb3VyY2VTdHJhdGVneSB0byBmdWxmaWxsIHRob3NlIGN1c3RvbSBxdWVyaWVzLlxuICpcbiAqIE5vdGUgdGhhdCB3ZSBkbyBub3Qgc2NhbiBmb3IgYFN1YnNjcmlwdGlvbmAgZmllbGRzOiBgQHNxbGAgZGlyZWN0aXZlcyBhcmUgbm90IGFsbG93ZWQgb24gdGhvc2UsIGFuZCBpdCB3b3VsZG4ndCBtYWtlIHNlbnNlIHRvIGRvIHNvXG4gKiBhbnl3YXksIHNpbmNlIHN1YnNjcmlwdGlvbnMgYXJlIHByb2Nlc3NlZCBmcm9tIGFuIGluY29taW5nIE11dGF0aW9uLCBub3QgYXMgdGhlIHJlc3VsdCBvZiBhIGRpcmVjdCBkYXRhc291cmNlIGFjY2Vzcy5cbiAqXG4gKiBUT0RPOiBSZXdvcmQgdGhpcyB3aGVuIHdlIHJlZmFjdG9yIHRvIHVzZSBTdHJhdGVnaWVzIHRocm91Z2hvdXQgdGhlIGltcGxlbWVudGF0aW9uIHJhdGhlciB0aGFuIERhdGFTb3VyY2VzLlxuICovXG5leHBvcnQgY29uc3QgY29uc3RydWN0Q3VzdG9tU3FsRGF0YVNvdXJjZVN0cmF0ZWdpZXMgPSAoXG4gIHNjaGVtYTogc3RyaW5nLFxuICBkYXRhU291cmNlU3RyYXRlZ3k6IE1vZGVsRGF0YVNvdXJjZVN0cmF0ZWd5LFxuKTogSW50ZXJmYWNlQ3VzdG9tU3FsRGF0YVNvdXJjZVN0cmF0ZWd5W10gPT4ge1xuICBpZiAoIWlzU3FsU3RyYXRlZ3koZGF0YVNvdXJjZVN0cmF0ZWd5KSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IHBhcnNlZFNjaGVtYSA9IHBhcnNlKHNjaGVtYSk7XG5cbiAgY29uc3QgcXVlcnlOb2RlID0gcGFyc2VkU2NoZW1hLmRlZmluaXRpb25zLmZpbmQoaXNRdWVyeU5vZGUpO1xuICBjb25zdCBtdXRhdGlvbk5vZGUgPSBwYXJzZWRTY2hlbWEuZGVmaW5pdGlvbnMuZmluZChpc011dGF0aW9uTm9kZSk7XG4gIGlmICghcXVlcnlOb2RlICYmICFtdXRhdGlvbk5vZGUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBjdXN0b21TcWxEYXRhU291cmNlU3RyYXRlZ2llczogSW50ZXJmYWNlQ3VzdG9tU3FsRGF0YVNvdXJjZVN0cmF0ZWd5W10gPSBbXTtcblxuICBpZiAocXVlcnlOb2RlKSB7XG4gICAgY29uc3QgZmllbGRzID0gZmllbGRzV2l0aFNxbERpcmVjdGl2ZShxdWVyeU5vZGUpO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICBjdXN0b21TcWxEYXRhU291cmNlU3RyYXRlZ2llcy5wdXNoKHtcbiAgICAgICAgdHlwZU5hbWU6ICdRdWVyeScsXG4gICAgICAgIGZpZWxkTmFtZTogZmllbGQubmFtZS52YWx1ZSxcbiAgICAgICAgc3RyYXRlZ3k6IGRhdGFTb3VyY2VTdHJhdGVneSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXRhdGlvbk5vZGUpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBmaWVsZHNXaXRoU3FsRGlyZWN0aXZlKG11dGF0aW9uTm9kZSk7XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgIGN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVnaWVzLnB1c2goe1xuICAgICAgICB0eXBlTmFtZTogJ011dGF0aW9uJyxcbiAgICAgICAgZmllbGROYW1lOiBmaWVsZC5uYW1lLnZhbHVlLFxuICAgICAgICBzdHJhdGVneTogZGF0YVNvdXJjZVN0cmF0ZWd5LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVnaWVzO1xufTtcblxuLyoqXG4gKiBXZSBjdXJyZW50bHkgdXNlIGEgZGlmZmVyZW50IHR5cGUgc3RydWN0dXJlIHRvIG1vZGVsIHN0cmF0ZWdpZXMgaW4gdGhlIGludGVyZmFjZSB0aGFuIHdlIGRvIGluIHRoZSBpbXBsZW1lbnRhdGlvbi4gVGhpcyBtYXBzIHRoZVxuICogaW50ZXJmYWNlIEN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVneSAod2hpY2ggdXNlcyBTUUxMYW1iZGFNb2RlbERhdGFTb3VyY2VTdHJhdGVneSkgdG8gdGhlIGltcGxlbWVudGF0aW9uIGZsYXZvciAod2hpY2ggdXNlc1xuICogRGF0YVNvdXJjZVR5cGUpLlxuICpcbiAqIFRPRE86IFJlbW92ZSB0aGlzIG9uY2Ugd2UgcmVmYWN0b3IgdGhlIGludGVybmFscyB0byB1c2Ugc3RyYXRlZ2llcyByYXRoZXIgdGhhbiBEYXRhU291cmNlVHlwZXNcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcEludGVyZmFjZUN1c3RvbVNxbFN0cmF0ZWdpZXNUb0ltcGxlbWVudGF0aW9uU3RyYXRlZ2llcyA9IChcbiAgc3RyYXRlZ2llcz86IEludGVyZmFjZUN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVneVtdLFxuKTogSW1wbGVtZW50YXRpb25DdXN0b21TcWxEYXRhU291cmNlU3RyYXRlZ3lbXSA9PiB7XG4gIGlmICghc3RyYXRlZ2llcykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gc3RyYXRlZ2llcy5tYXAoKGludGVyZmFjZVN0cmF0ZWd5KSA9PiAoe1xuICAgIGZpZWxkTmFtZTogaW50ZXJmYWNlU3RyYXRlZ3kuZmllbGROYW1lLFxuICAgIHR5cGVOYW1lOiBpbnRlcmZhY2VTdHJhdGVneS50eXBlTmFtZSxcbiAgICBkYXRhU291cmNlVHlwZToge1xuICAgICAgZGJUeXBlOiBub3JtYWxpemVEYlR5cGUoaW50ZXJmYWNlU3RyYXRlZ3kuc3RyYXRlZ3kuZGJUeXBlKSxcbiAgICAgIHByb3Zpc2lvbkRCOiBmYWxzZSxcbiAgICAgIHByb3Zpc2lvblN0cmF0ZWd5OiBTUUxMYW1iZGFNb2RlbFByb3Zpc2lvblN0cmF0ZWd5LkRFRkFVTFQsXG4gICAgfSxcbiAgfSkpO1xufTtcbiJdfQ==