import { AsyncLocalStorage } from 'node:async_hooks';
class OutputInterceptor {
    output = '';
    append = (chunk) => {
        this.output += chunk;
    };
    getOutput = () => this.output;
}
const asyncLocalStorage = new AsyncLocalStorage();
// Casting original write to Function to disable compiler safety intentionally.
// The process.stdout.write has many overloads and it's impossible to get right types here.
// We're passing unchanged argument list to original method, therefore this is safe.
// eslint-disable-next-line @typescript-eslint/ban-types
const createInterceptedWrite = (originalWrite) => {
    return (...args) => {
        const interceptor = asyncLocalStorage.getStore();
        if (interceptor && args.length > 0 && typeof args[0] === 'string') {
            interceptor.append(args[0]);
        }
        return originalWrite(...args);
    };
};
const originalStdoutWrite = process.stdout.write.bind(process.stdout);
process.stdout.write = createInterceptedWrite(originalStdoutWrite);
const originalStderrWrite = process.stderr.write.bind(process.stderr);
process.stderr.write = createInterceptedWrite(originalStderrWrite);
/**
 * An error that has both output and error that occurred during command execution.
 */
export class TestCommandError extends Error {
    error;
    output;
    /**
     * Creates new test command error.
     */
    constructor(error, output) {
        super();
        this.error = error;
        this.output = output;
    }
}
/**
 * Runs commands given preconfigured yargs parser.
 */
export class TestCommandRunner {
    parser;
    /**
     * Creates new command runner.
     */
    constructor(parser) {
        this.parser = parser
            // Pin locale
            .locale('en')
            // Override script name to avoid long test file names
            .scriptName('amplify')
            // Make sure we don't exit process on error or --help
            .exitProcess(false);
    }
    /**
     * Runs a command. Returns command output or throws an error if command failed.
     */
    runCommand = async (args) => {
        const interceptor = new OutputInterceptor();
        try {
            // We are using AsyncLocalStorage and OutputInterceptor to capture stdout and stdin streams into memory
            // instead of using parse/parseAsync with callback.
            // The reasons are:
            // - parse/parseAsync with callback leaves orphan promises that trigger unhandledRejection handler in tests
            // - parse/parseAsync with callback have edge cases if command builder and handler methods are sync or async
            //   see https://github.com/yargs/yargs/issues/1069
            //   and https://github.com/yargs/yargs/blob/main/docs/api.md#parseargs-context-parsecallback
            // - callback can only capture yargs logger outputs. it can't capture messages emitted from our code
            //
            // AsyncLocalStorage is used to make sure that we're capturing outputs only from the same asynchronous context
            // in potentially concurrent environment.
            await asyncLocalStorage.run(interceptor, async () => {
                await this.parser.parseAsync(args);
            });
            return interceptor.getOutput();
        }
        catch (err) {
            throw new TestCommandError(err, interceptor.getOutput());
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbWFuZF9ydW5uZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdGVzdC11dGlscy9jb21tYW5kX3J1bm5lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUVyRCxNQUFNLGlCQUFpQjtJQUNiLE1BQU0sR0FBRyxFQUFFLENBQUM7SUFDcEIsTUFBTSxHQUFHLENBQUMsS0FBYSxFQUFFLEVBQUU7UUFDekIsSUFBSSxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUM7SUFDdkIsQ0FBQyxDQUFDO0lBQ0YsU0FBUyxHQUFHLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7Q0FDL0I7QUFFRCxNQUFNLGlCQUFpQixHQUFHLElBQUksaUJBQWlCLEVBQXFCLENBQUM7QUFFckUsK0VBQStFO0FBQy9FLDJGQUEyRjtBQUMzRixvRkFBb0Y7QUFDcEYsd0RBQXdEO0FBQ3hELE1BQU0sc0JBQXNCLEdBQUcsQ0FBQyxhQUF1QixFQUFFLEVBQUU7SUFDekQsT0FBTyxDQUFDLEdBQUcsSUFBYSxFQUFFLEVBQUU7UUFDMUIsTUFBTSxXQUFXLEdBQ2YsaUJBQWlCLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDL0IsSUFBSSxXQUFXLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssUUFBUSxFQUFFO1lBQ2pFLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDN0I7UUFFRCxPQUFPLGFBQWEsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0lBQ2hDLENBQUMsQ0FBQztBQUNKLENBQUMsQ0FBQztBQUNGLE1BQU0sbUJBQW1CLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN0RSxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxzQkFBc0IsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBRW5FLE1BQU0sbUJBQW1CLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN0RSxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxzQkFBc0IsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBRW5FOztHQUVHO0FBQ0gsTUFBTSxPQUFPLGdCQUFpQixTQUFRLEtBQUs7SUFJcEI7SUFBdUI7SUFINUM7O09BRUc7SUFDSCxZQUFxQixLQUFZLEVBQVcsTUFBYztRQUN4RCxLQUFLLEVBQUUsQ0FBQztRQURXLFVBQUssR0FBTCxLQUFLLENBQU87UUFBVyxXQUFNLEdBQU4sTUFBTSxDQUFRO0lBRTFELENBQUM7Q0FDRjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLGlCQUFpQjtJQUNYLE1BQU0sQ0FBTztJQUU5Qjs7T0FFRztJQUNILFlBQVksTUFBWTtRQUN0QixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU07WUFDbEIsYUFBYTthQUNaLE1BQU0sQ0FBQyxJQUFJLENBQUM7WUFDYixxREFBcUQ7YUFDcEQsVUFBVSxDQUFDLFNBQVMsQ0FBQztZQUN0QixxREFBcUQ7YUFDcEQsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7T0FFRztJQUNILFVBQVUsR0FBRyxLQUFLLEVBQUUsSUFBNEIsRUFBbUIsRUFBRTtRQUNuRSxNQUFNLFdBQVcsR0FBRyxJQUFJLGlCQUFpQixFQUFFLENBQUM7UUFDNUMsSUFBSTtZQUNGLHVHQUF1RztZQUN2RyxtREFBbUQ7WUFDbkQsbUJBQW1CO1lBQ25CLDJHQUEyRztZQUMzRyw0R0FBNEc7WUFDNUcsbURBQW1EO1lBQ25ELDZGQUE2RjtZQUM3RixvR0FBb0c7WUFDcEcsRUFBRTtZQUNGLDhHQUE4RztZQUM5Ryx5Q0FBeUM7WUFDekMsTUFBTSxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLEtBQUssSUFBSSxFQUFFO2dCQUNsRCxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3JDLENBQUMsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxXQUFXLENBQUMsU0FBUyxFQUFFLENBQUM7U0FDaEM7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNaLE1BQU0sSUFBSSxnQkFBZ0IsQ0FBQyxHQUFZLEVBQUUsV0FBVyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7U0FDbkU7SUFDSCxDQUFDLENBQUM7Q0FDSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFyZ3YgfSBmcm9tICd5YXJncyc7XG5pbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZSB9IGZyb20gJ25vZGU6YXN5bmNfaG9va3MnO1xuXG5jbGFzcyBPdXRwdXRJbnRlcmNlcHRvciB7XG4gIHByaXZhdGUgb3V0cHV0ID0gJyc7XG4gIGFwcGVuZCA9IChjaHVuazogc3RyaW5nKSA9PiB7XG4gICAgdGhpcy5vdXRwdXQgKz0gY2h1bms7XG4gIH07XG4gIGdldE91dHB1dCA9ICgpID0+IHRoaXMub3V0cHV0O1xufVxuXG5jb25zdCBhc3luY0xvY2FsU3RvcmFnZSA9IG5ldyBBc3luY0xvY2FsU3RvcmFnZTxPdXRwdXRJbnRlcmNlcHRvcj4oKTtcblxuLy8gQ2FzdGluZyBvcmlnaW5hbCB3cml0ZSB0byBGdW5jdGlvbiB0byBkaXNhYmxlIGNvbXBpbGVyIHNhZmV0eSBpbnRlbnRpb25hbGx5LlxuLy8gVGhlIHByb2Nlc3Muc3Rkb3V0LndyaXRlIGhhcyBtYW55IG92ZXJsb2FkcyBhbmQgaXQncyBpbXBvc3NpYmxlIHRvIGdldCByaWdodCB0eXBlcyBoZXJlLlxuLy8gV2UncmUgcGFzc2luZyB1bmNoYW5nZWQgYXJndW1lbnQgbGlzdCB0byBvcmlnaW5hbCBtZXRob2QsIHRoZXJlZm9yZSB0aGlzIGlzIHNhZmUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuY29uc3QgY3JlYXRlSW50ZXJjZXB0ZWRXcml0ZSA9IChvcmlnaW5hbFdyaXRlOiBGdW5jdGlvbikgPT4ge1xuICByZXR1cm4gKC4uLmFyZ3M6IG5ldmVyW10pID0+IHtcbiAgICBjb25zdCBpbnRlcmNlcHRvcjogT3V0cHV0SW50ZXJjZXB0b3IgfCB1bmRlZmluZWQgPVxuICAgICAgYXN5bmNMb2NhbFN0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICBpZiAoaW50ZXJjZXB0b3IgJiYgYXJncy5sZW5ndGggPiAwICYmIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgaW50ZXJjZXB0b3IuYXBwZW5kKGFyZ3NbMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBvcmlnaW5hbFdyaXRlKC4uLmFyZ3MpO1xuICB9O1xufTtcbmNvbnN0IG9yaWdpbmFsU3Rkb3V0V3JpdGUgPSBwcm9jZXNzLnN0ZG91dC53cml0ZS5iaW5kKHByb2Nlc3Muc3Rkb3V0KTtcbnByb2Nlc3Muc3Rkb3V0LndyaXRlID0gY3JlYXRlSW50ZXJjZXB0ZWRXcml0ZShvcmlnaW5hbFN0ZG91dFdyaXRlKTtcblxuY29uc3Qgb3JpZ2luYWxTdGRlcnJXcml0ZSA9IHByb2Nlc3Muc3RkZXJyLndyaXRlLmJpbmQocHJvY2Vzcy5zdGRlcnIpO1xucHJvY2Vzcy5zdGRlcnIud3JpdGUgPSBjcmVhdGVJbnRlcmNlcHRlZFdyaXRlKG9yaWdpbmFsU3RkZXJyV3JpdGUpO1xuXG4vKipcbiAqIEFuIGVycm9yIHRoYXQgaGFzIGJvdGggb3V0cHV0IGFuZCBlcnJvciB0aGF0IG9jY3VycmVkIGR1cmluZyBjb21tYW5kIGV4ZWN1dGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFRlc3RDb21tYW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIG5ldyB0ZXN0IGNvbW1hbmQgZXJyb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZWFkb25seSBlcnJvcjogRXJyb3IsIHJlYWRvbmx5IG91dHB1dDogc3RyaW5nKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnMgY29tbWFuZHMgZ2l2ZW4gcHJlY29uZmlndXJlZCB5YXJncyBwYXJzZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXN0Q29tbWFuZFJ1bm5lciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgcGFyc2VyOiBBcmd2O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG5ldyBjb21tYW5kIHJ1bm5lci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcnNlcjogQXJndikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyXG4gICAgICAvLyBQaW4gbG9jYWxlXG4gICAgICAubG9jYWxlKCdlbicpXG4gICAgICAvLyBPdmVycmlkZSBzY3JpcHQgbmFtZSB0byBhdm9pZCBsb25nIHRlc3QgZmlsZSBuYW1lc1xuICAgICAgLnNjcmlwdE5hbWUoJ2FtcGxpZnknKVxuICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IGV4aXQgcHJvY2VzcyBvbiBlcnJvciBvciAtLWhlbHBcbiAgICAgIC5leGl0UHJvY2VzcyhmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogUnVucyBhIGNvbW1hbmQuIFJldHVybnMgY29tbWFuZCBvdXRwdXQgb3IgdGhyb3dzIGFuIGVycm9yIGlmIGNvbW1hbmQgZmFpbGVkLlxuICAgKi9cbiAgcnVuQ29tbWFuZCA9IGFzeW5jIChhcmdzOiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+KTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBjb25zdCBpbnRlcmNlcHRvciA9IG5ldyBPdXRwdXRJbnRlcmNlcHRvcigpO1xuICAgIHRyeSB7XG4gICAgICAvLyBXZSBhcmUgdXNpbmcgQXN5bmNMb2NhbFN0b3JhZ2UgYW5kIE91dHB1dEludGVyY2VwdG9yIHRvIGNhcHR1cmUgc3Rkb3V0IGFuZCBzdGRpbiBzdHJlYW1zIGludG8gbWVtb3J5XG4gICAgICAvLyBpbnN0ZWFkIG9mIHVzaW5nIHBhcnNlL3BhcnNlQXN5bmMgd2l0aCBjYWxsYmFjay5cbiAgICAgIC8vIFRoZSByZWFzb25zIGFyZTpcbiAgICAgIC8vIC0gcGFyc2UvcGFyc2VBc3luYyB3aXRoIGNhbGxiYWNrIGxlYXZlcyBvcnBoYW4gcHJvbWlzZXMgdGhhdCB0cmlnZ2VyIHVuaGFuZGxlZFJlamVjdGlvbiBoYW5kbGVyIGluIHRlc3RzXG4gICAgICAvLyAtIHBhcnNlL3BhcnNlQXN5bmMgd2l0aCBjYWxsYmFjayBoYXZlIGVkZ2UgY2FzZXMgaWYgY29tbWFuZCBidWlsZGVyIGFuZCBoYW5kbGVyIG1ldGhvZHMgYXJlIHN5bmMgb3IgYXN5bmNcbiAgICAgIC8vICAgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95YXJncy95YXJncy9pc3N1ZXMvMTA2OVxuICAgICAgLy8gICBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3lhcmdzL3lhcmdzL2Jsb2IvbWFpbi9kb2NzL2FwaS5tZCNwYXJzZWFyZ3MtY29udGV4dC1wYXJzZWNhbGxiYWNrXG4gICAgICAvLyAtIGNhbGxiYWNrIGNhbiBvbmx5IGNhcHR1cmUgeWFyZ3MgbG9nZ2VyIG91dHB1dHMuIGl0IGNhbid0IGNhcHR1cmUgbWVzc2FnZXMgZW1pdHRlZCBmcm9tIG91ciBjb2RlXG4gICAgICAvL1xuICAgICAgLy8gQXN5bmNMb2NhbFN0b3JhZ2UgaXMgdXNlZCB0byBtYWtlIHN1cmUgdGhhdCB3ZSdyZSBjYXB0dXJpbmcgb3V0cHV0cyBvbmx5IGZyb20gdGhlIHNhbWUgYXN5bmNocm9ub3VzIGNvbnRleHRcbiAgICAgIC8vIGluIHBvdGVudGlhbGx5IGNvbmN1cnJlbnQgZW52aXJvbm1lbnQuXG4gICAgICBhd2FpdCBhc3luY0xvY2FsU3RvcmFnZS5ydW4oaW50ZXJjZXB0b3IsIGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5wYXJzZXIucGFyc2VBc3luYyhhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGludGVyY2VwdG9yLmdldE91dHB1dCgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IFRlc3RDb21tYW5kRXJyb3IoZXJyIGFzIEVycm9yLCBpbnRlcmNlcHRvci5nZXRPdXRwdXQoKSk7XG4gICAgfVxuICB9O1xufVxuIl19