"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.packageJsonSchema = exports.PackageJsonReader = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const zod_1 = __importDefault(require("zod"));
/**
 * return the package json
 */
class PackageJsonReader {
    read = (absolutePackageJsonPath) => {
        if (!fs_1.default.existsSync(absolutePackageJsonPath)) {
            throw new Error(`Could not find a package.json file at ${absolutePackageJsonPath}`);
        }
        let jsonParsedValue;
        try {
            jsonParsedValue = JSON.parse(
            // we have to use sync fs methods here because this is also used during cdk synth
            fs_1.default.readFileSync(absolutePackageJsonPath, 'utf-8'));
        }
        catch (err) {
            throw new Error(`Could not JSON.parse the contents of ${absolutePackageJsonPath}`);
        }
        return exports.packageJsonSchema.parse(jsonParsedValue);
    };
    /**
     * Returns the contents of the package.json file in process.cwd()
     *
     * If no package.json file exists, or the content does not pass validation, an error is thrown
     */
    readFromCwd = () => {
        return this.read(path_1.default.resolve(process.cwd(), 'package.json'));
    };
}
exports.PackageJsonReader = PackageJsonReader;
/**
 * Type for package.json content.
 *
 * Add additional validation if there are other fields we need to read
 */
exports.packageJsonSchema = zod_1.default.object({
    name: zod_1.default.string().optional(),
    version: zod_1.default.string().optional(),
    type: zod_1.default.union([zod_1.default.literal('module'), zod_1.default.literal('commonjs')]).optional(),
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZV9qc29uX3JlYWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9wYWNrYWdlX2pzb25fcmVhZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDRDQUFvQjtBQUNwQixnREFBd0I7QUFDeEIsOENBQW9CO0FBRXBCOztHQUVHO0FBQ0gsTUFBYSxpQkFBaUI7SUFDNUIsSUFBSSxHQUFHLENBQUMsdUJBQStCLEVBQWUsRUFBRTtRQUN0RCxJQUFJLENBQUMsWUFBRSxDQUFDLFVBQVUsQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFO1lBQzNDLE1BQU0sSUFBSSxLQUFLLENBQ2IseUNBQXlDLHVCQUF1QixFQUFFLENBQ25FLENBQUM7U0FDSDtRQUNELElBQUksZUFBd0MsQ0FBQztRQUM3QyxJQUFJO1lBQ0YsZUFBZSxHQUFHLElBQUksQ0FBQyxLQUFLO1lBQzFCLGlGQUFpRjtZQUNqRixZQUFFLENBQUMsWUFBWSxDQUFDLHVCQUF1QixFQUFFLE9BQU8sQ0FBQyxDQUNsRCxDQUFDO1NBQ0g7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNaLE1BQU0sSUFBSSxLQUFLLENBQ2Isd0NBQXdDLHVCQUF1QixFQUFFLENBQ2xFLENBQUM7U0FDSDtRQUNELE9BQU8seUJBQWlCLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQ2xELENBQUMsQ0FBQztJQUVGOzs7O09BSUc7SUFDSCxXQUFXLEdBQUcsR0FBZ0IsRUFBRTtRQUM5QixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQztJQUNoRSxDQUFDLENBQUM7Q0FDSDtBQTdCRCw4Q0E2QkM7QUFFRDs7OztHQUlHO0FBQ1UsUUFBQSxpQkFBaUIsR0FBRyxhQUFDLENBQUMsTUFBTSxDQUFDO0lBQ3hDLElBQUksRUFBRSxhQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFO0lBQzNCLE9BQU8sRUFBRSxhQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFO0lBQzlCLElBQUksRUFBRSxhQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsYUFBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRSxhQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUU7Q0FDdkUsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHogZnJvbSAnem9kJztcblxuLyoqXG4gKiByZXR1cm4gdGhlIHBhY2thZ2UganNvblxuICovXG5leHBvcnQgY2xhc3MgUGFja2FnZUpzb25SZWFkZXIge1xuICByZWFkID0gKGFic29sdXRlUGFja2FnZUpzb25QYXRoOiBzdHJpbmcpOiBQYWNrYWdlSnNvbiA9PiB7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKGFic29sdXRlUGFja2FnZUpzb25QYXRoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ291bGQgbm90IGZpbmQgYSBwYWNrYWdlLmpzb24gZmlsZSBhdCAke2Fic29sdXRlUGFja2FnZUpzb25QYXRofWBcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBqc29uUGFyc2VkVmFsdWU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgIHRyeSB7XG4gICAgICBqc29uUGFyc2VkVmFsdWUgPSBKU09OLnBhcnNlKFxuICAgICAgICAvLyB3ZSBoYXZlIHRvIHVzZSBzeW5jIGZzIG1ldGhvZHMgaGVyZSBiZWNhdXNlIHRoaXMgaXMgYWxzbyB1c2VkIGR1cmluZyBjZGsgc3ludGhcbiAgICAgICAgZnMucmVhZEZpbGVTeW5jKGFic29sdXRlUGFja2FnZUpzb25QYXRoLCAndXRmLTgnKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENvdWxkIG5vdCBKU09OLnBhcnNlIHRoZSBjb250ZW50cyBvZiAke2Fic29sdXRlUGFja2FnZUpzb25QYXRofWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBwYWNrYWdlSnNvblNjaGVtYS5wYXJzZShqc29uUGFyc2VkVmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiB0aGUgcGFja2FnZS5qc29uIGZpbGUgaW4gcHJvY2Vzcy5jd2QoKVxuICAgKlxuICAgKiBJZiBubyBwYWNrYWdlLmpzb24gZmlsZSBleGlzdHMsIG9yIHRoZSBjb250ZW50IGRvZXMgbm90IHBhc3MgdmFsaWRhdGlvbiwgYW4gZXJyb3IgaXMgdGhyb3duXG4gICAqL1xuICByZWFkRnJvbUN3ZCA9ICgpOiBQYWNrYWdlSnNvbiA9PiB7XG4gICAgcmV0dXJuIHRoaXMucmVhZChwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgJ3BhY2thZ2UuanNvbicpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUeXBlIGZvciBwYWNrYWdlLmpzb24gY29udGVudC5cbiAqXG4gKiBBZGQgYWRkaXRpb25hbCB2YWxpZGF0aW9uIGlmIHRoZXJlIGFyZSBvdGhlciBmaWVsZHMgd2UgbmVlZCB0byByZWFkXG4gKi9cbmV4cG9ydCBjb25zdCBwYWNrYWdlSnNvblNjaGVtYSA9IHoub2JqZWN0KHtcbiAgbmFtZTogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICB2ZXJzaW9uOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHR5cGU6IHoudW5pb24oW3oubGl0ZXJhbCgnbW9kdWxlJyksIHoubGl0ZXJhbCgnY29tbW9uanMnKV0pLm9wdGlvbmFsKCksXG59KTtcblxuZXhwb3J0IHR5cGUgUGFja2FnZUpzb24gPSB6LmluZmVyPHR5cGVvZiBwYWNrYWdlSnNvblNjaGVtYT47XG4iXX0=